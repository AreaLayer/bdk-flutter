// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$BdkError {
  Object get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BitcoinHexError field0) hexError,
    required TResult Function(BitcoinConsensusError field0) consensusError,
    required TResult Function(BitcoinAddressError field0) addressError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BitcoinHexError field0)? hexError,
    TResult? Function(BitcoinConsensusError field0)? consensusError,
    TResult? Function(BitcoinAddressError field0)? addressError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BitcoinHexError field0)? hexError,
    TResult Function(BitcoinConsensusError field0)? consensusError,
    TResult Function(BitcoinAddressError field0)? addressError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BdkError_HexError value) hexError,
    required TResult Function(BdkError_ConsensusError value) consensusError,
    required TResult Function(BdkError_AddressError value) addressError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BdkError_HexError value)? hexError,
    TResult? Function(BdkError_ConsensusError value)? consensusError,
    TResult? Function(BdkError_AddressError value)? addressError,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BdkError_HexError value)? hexError,
    TResult Function(BdkError_ConsensusError value)? consensusError,
    TResult Function(BdkError_AddressError value)? addressError,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BdkErrorCopyWith<$Res> {
  factory $BdkErrorCopyWith(BdkError value, $Res Function(BdkError) then) =
      _$BdkErrorCopyWithImpl<$Res, BdkError>;
}

/// @nodoc
class _$BdkErrorCopyWithImpl<$Res, $Val extends BdkError>
    implements $BdkErrorCopyWith<$Res> {
  _$BdkErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BdkError_HexErrorImplCopyWith<$Res> {
  factory _$$BdkError_HexErrorImplCopyWith(_$BdkError_HexErrorImpl value,
          $Res Function(_$BdkError_HexErrorImpl) then) =
      __$$BdkError_HexErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BitcoinHexError field0});

  $BitcoinHexErrorCopyWith<$Res> get field0;
}

/// @nodoc
class __$$BdkError_HexErrorImplCopyWithImpl<$Res>
    extends _$BdkErrorCopyWithImpl<$Res, _$BdkError_HexErrorImpl>
    implements _$$BdkError_HexErrorImplCopyWith<$Res> {
  __$$BdkError_HexErrorImplCopyWithImpl(_$BdkError_HexErrorImpl _value,
      $Res Function(_$BdkError_HexErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BdkError_HexErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BitcoinHexError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BitcoinHexErrorCopyWith<$Res> get field0 {
    return $BitcoinHexErrorCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$BdkError_HexErrorImpl implements BdkError_HexError {
  const _$BdkError_HexErrorImpl(this.field0);

  @override
  final BitcoinHexError field0;

  @override
  String toString() {
    return 'BdkError.hexError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BdkError_HexErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BdkError_HexErrorImplCopyWith<_$BdkError_HexErrorImpl> get copyWith =>
      __$$BdkError_HexErrorImplCopyWithImpl<_$BdkError_HexErrorImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BitcoinHexError field0) hexError,
    required TResult Function(BitcoinConsensusError field0) consensusError,
    required TResult Function(BitcoinAddressError field0) addressError,
  }) {
    return hexError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BitcoinHexError field0)? hexError,
    TResult? Function(BitcoinConsensusError field0)? consensusError,
    TResult? Function(BitcoinAddressError field0)? addressError,
  }) {
    return hexError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BitcoinHexError field0)? hexError,
    TResult Function(BitcoinConsensusError field0)? consensusError,
    TResult Function(BitcoinAddressError field0)? addressError,
    required TResult orElse(),
  }) {
    if (hexError != null) {
      return hexError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BdkError_HexError value) hexError,
    required TResult Function(BdkError_ConsensusError value) consensusError,
    required TResult Function(BdkError_AddressError value) addressError,
  }) {
    return hexError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BdkError_HexError value)? hexError,
    TResult? Function(BdkError_ConsensusError value)? consensusError,
    TResult? Function(BdkError_AddressError value)? addressError,
  }) {
    return hexError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BdkError_HexError value)? hexError,
    TResult Function(BdkError_ConsensusError value)? consensusError,
    TResult Function(BdkError_AddressError value)? addressError,
    required TResult orElse(),
  }) {
    if (hexError != null) {
      return hexError(this);
    }
    return orElse();
  }
}

abstract class BdkError_HexError implements BdkError {
  const factory BdkError_HexError(final BitcoinHexError field0) =
      _$BdkError_HexErrorImpl;

  @override
  BitcoinHexError get field0;
  @JsonKey(ignore: true)
  _$$BdkError_HexErrorImplCopyWith<_$BdkError_HexErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BdkError_ConsensusErrorImplCopyWith<$Res> {
  factory _$$BdkError_ConsensusErrorImplCopyWith(
          _$BdkError_ConsensusErrorImpl value,
          $Res Function(_$BdkError_ConsensusErrorImpl) then) =
      __$$BdkError_ConsensusErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BitcoinConsensusError field0});

  $BitcoinConsensusErrorCopyWith<$Res> get field0;
}

/// @nodoc
class __$$BdkError_ConsensusErrorImplCopyWithImpl<$Res>
    extends _$BdkErrorCopyWithImpl<$Res, _$BdkError_ConsensusErrorImpl>
    implements _$$BdkError_ConsensusErrorImplCopyWith<$Res> {
  __$$BdkError_ConsensusErrorImplCopyWithImpl(
      _$BdkError_ConsensusErrorImpl _value,
      $Res Function(_$BdkError_ConsensusErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BdkError_ConsensusErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BitcoinConsensusError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BitcoinConsensusErrorCopyWith<$Res> get field0 {
    return $BitcoinConsensusErrorCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$BdkError_ConsensusErrorImpl implements BdkError_ConsensusError {
  const _$BdkError_ConsensusErrorImpl(this.field0);

  @override
  final BitcoinConsensusError field0;

  @override
  String toString() {
    return 'BdkError.consensusError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BdkError_ConsensusErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BdkError_ConsensusErrorImplCopyWith<_$BdkError_ConsensusErrorImpl>
      get copyWith => __$$BdkError_ConsensusErrorImplCopyWithImpl<
          _$BdkError_ConsensusErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BitcoinHexError field0) hexError,
    required TResult Function(BitcoinConsensusError field0) consensusError,
    required TResult Function(BitcoinAddressError field0) addressError,
  }) {
    return consensusError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BitcoinHexError field0)? hexError,
    TResult? Function(BitcoinConsensusError field0)? consensusError,
    TResult? Function(BitcoinAddressError field0)? addressError,
  }) {
    return consensusError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BitcoinHexError field0)? hexError,
    TResult Function(BitcoinConsensusError field0)? consensusError,
    TResult Function(BitcoinAddressError field0)? addressError,
    required TResult orElse(),
  }) {
    if (consensusError != null) {
      return consensusError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BdkError_HexError value) hexError,
    required TResult Function(BdkError_ConsensusError value) consensusError,
    required TResult Function(BdkError_AddressError value) addressError,
  }) {
    return consensusError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BdkError_HexError value)? hexError,
    TResult? Function(BdkError_ConsensusError value)? consensusError,
    TResult? Function(BdkError_AddressError value)? addressError,
  }) {
    return consensusError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BdkError_HexError value)? hexError,
    TResult Function(BdkError_ConsensusError value)? consensusError,
    TResult Function(BdkError_AddressError value)? addressError,
    required TResult orElse(),
  }) {
    if (consensusError != null) {
      return consensusError(this);
    }
    return orElse();
  }
}

abstract class BdkError_ConsensusError implements BdkError {
  const factory BdkError_ConsensusError(final BitcoinConsensusError field0) =
      _$BdkError_ConsensusErrorImpl;

  @override
  BitcoinConsensusError get field0;
  @JsonKey(ignore: true)
  _$$BdkError_ConsensusErrorImplCopyWith<_$BdkError_ConsensusErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BdkError_AddressErrorImplCopyWith<$Res> {
  factory _$$BdkError_AddressErrorImplCopyWith(
          _$BdkError_AddressErrorImpl value,
          $Res Function(_$BdkError_AddressErrorImpl) then) =
      __$$BdkError_AddressErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({BitcoinAddressError field0});

  $BitcoinAddressErrorCopyWith<$Res> get field0;
}

/// @nodoc
class __$$BdkError_AddressErrorImplCopyWithImpl<$Res>
    extends _$BdkErrorCopyWithImpl<$Res, _$BdkError_AddressErrorImpl>
    implements _$$BdkError_AddressErrorImplCopyWith<$Res> {
  __$$BdkError_AddressErrorImplCopyWithImpl(_$BdkError_AddressErrorImpl _value,
      $Res Function(_$BdkError_AddressErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BdkError_AddressErrorImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as BitcoinAddressError,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BitcoinAddressErrorCopyWith<$Res> get field0 {
    return $BitcoinAddressErrorCopyWith<$Res>(_value.field0, (value) {
      return _then(_value.copyWith(field0: value));
    });
  }
}

/// @nodoc

class _$BdkError_AddressErrorImpl implements BdkError_AddressError {
  const _$BdkError_AddressErrorImpl(this.field0);

  @override
  final BitcoinAddressError field0;

  @override
  String toString() {
    return 'BdkError.addressError(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BdkError_AddressErrorImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BdkError_AddressErrorImplCopyWith<_$BdkError_AddressErrorImpl>
      get copyWith => __$$BdkError_AddressErrorImplCopyWithImpl<
          _$BdkError_AddressErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BitcoinHexError field0) hexError,
    required TResult Function(BitcoinConsensusError field0) consensusError,
    required TResult Function(BitcoinAddressError field0) addressError,
  }) {
    return addressError(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BitcoinHexError field0)? hexError,
    TResult? Function(BitcoinConsensusError field0)? consensusError,
    TResult? Function(BitcoinAddressError field0)? addressError,
  }) {
    return addressError?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BitcoinHexError field0)? hexError,
    TResult Function(BitcoinConsensusError field0)? consensusError,
    TResult Function(BitcoinAddressError field0)? addressError,
    required TResult orElse(),
  }) {
    if (addressError != null) {
      return addressError(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BdkError_HexError value) hexError,
    required TResult Function(BdkError_ConsensusError value) consensusError,
    required TResult Function(BdkError_AddressError value) addressError,
  }) {
    return addressError(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BdkError_HexError value)? hexError,
    TResult? Function(BdkError_ConsensusError value)? consensusError,
    TResult? Function(BdkError_AddressError value)? addressError,
  }) {
    return addressError?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BdkError_HexError value)? hexError,
    TResult Function(BdkError_ConsensusError value)? consensusError,
    TResult Function(BdkError_AddressError value)? addressError,
    required TResult orElse(),
  }) {
    if (addressError != null) {
      return addressError(this);
    }
    return orElse();
  }
}

abstract class BdkError_AddressError implements BdkError {
  const factory BdkError_AddressError(final BitcoinAddressError field0) =
      _$BdkError_AddressErrorImpl;

  @override
  BitcoinAddressError get field0;
  @JsonKey(ignore: true)
  _$$BdkError_AddressErrorImplCopyWith<_$BdkError_AddressErrorImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BitcoinAddressError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BitcoinAddressErrorCopyWith<$Res> {
  factory $BitcoinAddressErrorCopyWith(
          BitcoinAddressError value, $Res Function(BitcoinAddressError) then) =
      _$BitcoinAddressErrorCopyWithImpl<$Res, BitcoinAddressError>;
}

/// @nodoc
class _$BitcoinAddressErrorCopyWithImpl<$Res, $Val extends BitcoinAddressError>
    implements $BitcoinAddressErrorCopyWith<$Res> {
  _$BitcoinAddressErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BitcoinAddressError_Base58ImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_Base58ImplCopyWith(
          _$BitcoinAddressError_Base58Impl value,
          $Res Function(_$BitcoinAddressError_Base58Impl) then) =
      __$$BitcoinAddressError_Base58ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BitcoinAddressError_Base58ImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_Base58Impl>
    implements _$$BitcoinAddressError_Base58ImplCopyWith<$Res> {
  __$$BitcoinAddressError_Base58ImplCopyWithImpl(
      _$BitcoinAddressError_Base58Impl _value,
      $Res Function(_$BitcoinAddressError_Base58Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinAddressError_Base58Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_Base58Impl implements BitcoinAddressError_Base58 {
  const _$BitcoinAddressError_Base58Impl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'BitcoinAddressError.base58(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_Base58Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_Base58ImplCopyWith<_$BitcoinAddressError_Base58Impl>
      get copyWith => __$$BitcoinAddressError_Base58ImplCopyWithImpl<
          _$BitcoinAddressError_Base58Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return base58(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return base58?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (base58 != null) {
      return base58(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return base58(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return base58?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (base58 != null) {
      return base58(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_Base58 implements BitcoinAddressError {
  const factory BitcoinAddressError_Base58(final String field0) =
      _$BitcoinAddressError_Base58Impl;

  String get field0;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_Base58ImplCopyWith<_$BitcoinAddressError_Base58Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinAddressError_Bech32ImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_Bech32ImplCopyWith(
          _$BitcoinAddressError_Bech32Impl value,
          $Res Function(_$BitcoinAddressError_Bech32Impl) then) =
      __$$BitcoinAddressError_Bech32ImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BitcoinAddressError_Bech32ImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_Bech32Impl>
    implements _$$BitcoinAddressError_Bech32ImplCopyWith<$Res> {
  __$$BitcoinAddressError_Bech32ImplCopyWithImpl(
      _$BitcoinAddressError_Bech32Impl _value,
      $Res Function(_$BitcoinAddressError_Bech32Impl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinAddressError_Bech32Impl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_Bech32Impl implements BitcoinAddressError_Bech32 {
  const _$BitcoinAddressError_Bech32Impl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'BitcoinAddressError.bech32(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_Bech32Impl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_Bech32ImplCopyWith<_$BitcoinAddressError_Bech32Impl>
      get copyWith => __$$BitcoinAddressError_Bech32ImplCopyWithImpl<
          _$BitcoinAddressError_Bech32Impl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return bech32(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return bech32?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (bech32 != null) {
      return bech32(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return bech32(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return bech32?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (bech32 != null) {
      return bech32(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_Bech32 implements BitcoinAddressError {
  const factory BitcoinAddressError_Bech32(final String field0) =
      _$BitcoinAddressError_Bech32Impl;

  String get field0;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_Bech32ImplCopyWith<_$BitcoinAddressError_Bech32Impl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinAddressError_EmptyBech32PayloadImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_EmptyBech32PayloadImplCopyWith(
          _$BitcoinAddressError_EmptyBech32PayloadImpl value,
          $Res Function(_$BitcoinAddressError_EmptyBech32PayloadImpl) then) =
      __$$BitcoinAddressError_EmptyBech32PayloadImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BitcoinAddressError_EmptyBech32PayloadImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_EmptyBech32PayloadImpl>
    implements _$$BitcoinAddressError_EmptyBech32PayloadImplCopyWith<$Res> {
  __$$BitcoinAddressError_EmptyBech32PayloadImplCopyWithImpl(
      _$BitcoinAddressError_EmptyBech32PayloadImpl _value,
      $Res Function(_$BitcoinAddressError_EmptyBech32PayloadImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BitcoinAddressError_EmptyBech32PayloadImpl
    implements BitcoinAddressError_EmptyBech32Payload {
  const _$BitcoinAddressError_EmptyBech32PayloadImpl();

  @override
  String toString() {
    return 'BitcoinAddressError.emptyBech32Payload()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_EmptyBech32PayloadImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return emptyBech32Payload();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return emptyBech32Payload?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (emptyBech32Payload != null) {
      return emptyBech32Payload();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return emptyBech32Payload(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return emptyBech32Payload?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (emptyBech32Payload != null) {
      return emptyBech32Payload(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_EmptyBech32Payload
    implements BitcoinAddressError {
  const factory BitcoinAddressError_EmptyBech32Payload() =
      _$BitcoinAddressError_EmptyBech32PayloadImpl;
}

/// @nodoc
abstract class _$$BitcoinAddressError_InvalidBech32VariantImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_InvalidBech32VariantImplCopyWith(
          _$BitcoinAddressError_InvalidBech32VariantImpl value,
          $Res Function(_$BitcoinAddressError_InvalidBech32VariantImpl) then) =
      __$$BitcoinAddressError_InvalidBech32VariantImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Variant expected, Variant found});
}

/// @nodoc
class __$$BitcoinAddressError_InvalidBech32VariantImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_InvalidBech32VariantImpl>
    implements _$$BitcoinAddressError_InvalidBech32VariantImplCopyWith<$Res> {
  __$$BitcoinAddressError_InvalidBech32VariantImplCopyWithImpl(
      _$BitcoinAddressError_InvalidBech32VariantImpl _value,
      $Res Function(_$BitcoinAddressError_InvalidBech32VariantImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
    Object? found = null,
  }) {
    return _then(_$BitcoinAddressError_InvalidBech32VariantImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as Variant,
      found: null == found
          ? _value.found
          : found // ignore: cast_nullable_to_non_nullable
              as Variant,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_InvalidBech32VariantImpl
    implements BitcoinAddressError_InvalidBech32Variant {
  const _$BitcoinAddressError_InvalidBech32VariantImpl(
      {required this.expected, required this.found});

  @override
  final Variant expected;
  @override
  final Variant found;

  @override
  String toString() {
    return 'BitcoinAddressError.invalidBech32Variant(expected: $expected, found: $found)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_InvalidBech32VariantImpl &&
            (identical(other.expected, expected) ||
                other.expected == expected) &&
            (identical(other.found, found) || other.found == found));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expected, found);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_InvalidBech32VariantImplCopyWith<
          _$BitcoinAddressError_InvalidBech32VariantImpl>
      get copyWith =>
          __$$BitcoinAddressError_InvalidBech32VariantImplCopyWithImpl<
              _$BitcoinAddressError_InvalidBech32VariantImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return invalidBech32Variant(expected, found);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return invalidBech32Variant?.call(expected, found);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (invalidBech32Variant != null) {
      return invalidBech32Variant(expected, found);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return invalidBech32Variant(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return invalidBech32Variant?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (invalidBech32Variant != null) {
      return invalidBech32Variant(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_InvalidBech32Variant
    implements BitcoinAddressError {
  const factory BitcoinAddressError_InvalidBech32Variant(
          {required final Variant expected, required final Variant found}) =
      _$BitcoinAddressError_InvalidBech32VariantImpl;

  Variant get expected;
  Variant get found;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_InvalidBech32VariantImplCopyWith<
          _$BitcoinAddressError_InvalidBech32VariantImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinAddressError_InvalidWitnessVersionImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_InvalidWitnessVersionImplCopyWith(
          _$BitcoinAddressError_InvalidWitnessVersionImpl value,
          $Res Function(_$BitcoinAddressError_InvalidWitnessVersionImpl) then) =
      __$$BitcoinAddressError_InvalidWitnessVersionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$BitcoinAddressError_InvalidWitnessVersionImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_InvalidWitnessVersionImpl>
    implements _$$BitcoinAddressError_InvalidWitnessVersionImplCopyWith<$Res> {
  __$$BitcoinAddressError_InvalidWitnessVersionImplCopyWithImpl(
      _$BitcoinAddressError_InvalidWitnessVersionImpl _value,
      $Res Function(_$BitcoinAddressError_InvalidWitnessVersionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinAddressError_InvalidWitnessVersionImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_InvalidWitnessVersionImpl
    implements BitcoinAddressError_InvalidWitnessVersion {
  const _$BitcoinAddressError_InvalidWitnessVersionImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'BitcoinAddressError.invalidWitnessVersion(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_InvalidWitnessVersionImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_InvalidWitnessVersionImplCopyWith<
          _$BitcoinAddressError_InvalidWitnessVersionImpl>
      get copyWith =>
          __$$BitcoinAddressError_InvalidWitnessVersionImplCopyWithImpl<
                  _$BitcoinAddressError_InvalidWitnessVersionImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return invalidWitnessVersion(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return invalidWitnessVersion?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (invalidWitnessVersion != null) {
      return invalidWitnessVersion(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return invalidWitnessVersion(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return invalidWitnessVersion?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (invalidWitnessVersion != null) {
      return invalidWitnessVersion(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_InvalidWitnessVersion
    implements BitcoinAddressError {
  const factory BitcoinAddressError_InvalidWitnessVersion(final int field0) =
      _$BitcoinAddressError_InvalidWitnessVersionImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_InvalidWitnessVersionImplCopyWith<
          _$BitcoinAddressError_InvalidWitnessVersionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWith<
    $Res> {
  factory _$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWith(
          _$BitcoinAddressError_UnparsableWitnessVersionImpl value,
          $Res Function(_$BitcoinAddressError_UnparsableWitnessVersionImpl)
              then) =
      __$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_UnparsableWitnessVersionImpl>
    implements
        _$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWith<$Res> {
  __$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWithImpl(
      _$BitcoinAddressError_UnparsableWitnessVersionImpl _value,
      $Res Function(_$BitcoinAddressError_UnparsableWitnessVersionImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinAddressError_UnparsableWitnessVersionImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_UnparsableWitnessVersionImpl
    implements BitcoinAddressError_UnparsableWitnessVersion {
  const _$BitcoinAddressError_UnparsableWitnessVersionImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'BitcoinAddressError.unparsableWitnessVersion(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_UnparsableWitnessVersionImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWith<
          _$BitcoinAddressError_UnparsableWitnessVersionImpl>
      get copyWith =>
          __$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWithImpl<
                  _$BitcoinAddressError_UnparsableWitnessVersionImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return unparsableWitnessVersion(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return unparsableWitnessVersion?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (unparsableWitnessVersion != null) {
      return unparsableWitnessVersion(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return unparsableWitnessVersion(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return unparsableWitnessVersion?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (unparsableWitnessVersion != null) {
      return unparsableWitnessVersion(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_UnparsableWitnessVersion
    implements BitcoinAddressError {
  const factory BitcoinAddressError_UnparsableWitnessVersion(
      final String field0) = _$BitcoinAddressError_UnparsableWitnessVersionImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_UnparsableWitnessVersionImplCopyWith<
          _$BitcoinAddressError_UnparsableWitnessVersionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinAddressError_MalformedWitnessVersionImplCopyWith<
    $Res> {
  factory _$$BitcoinAddressError_MalformedWitnessVersionImplCopyWith(
          _$BitcoinAddressError_MalformedWitnessVersionImpl value,
          $Res Function(_$BitcoinAddressError_MalformedWitnessVersionImpl)
              then) =
      __$$BitcoinAddressError_MalformedWitnessVersionImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BitcoinAddressError_MalformedWitnessVersionImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_MalformedWitnessVersionImpl>
    implements
        _$$BitcoinAddressError_MalformedWitnessVersionImplCopyWith<$Res> {
  __$$BitcoinAddressError_MalformedWitnessVersionImplCopyWithImpl(
      _$BitcoinAddressError_MalformedWitnessVersionImpl _value,
      $Res Function(_$BitcoinAddressError_MalformedWitnessVersionImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BitcoinAddressError_MalformedWitnessVersionImpl
    implements BitcoinAddressError_MalformedWitnessVersion {
  const _$BitcoinAddressError_MalformedWitnessVersionImpl();

  @override
  String toString() {
    return 'BitcoinAddressError.malformedWitnessVersion()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_MalformedWitnessVersionImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return malformedWitnessVersion();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return malformedWitnessVersion?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (malformedWitnessVersion != null) {
      return malformedWitnessVersion();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return malformedWitnessVersion(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return malformedWitnessVersion?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (malformedWitnessVersion != null) {
      return malformedWitnessVersion(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_MalformedWitnessVersion
    implements BitcoinAddressError {
  const factory BitcoinAddressError_MalformedWitnessVersion() =
      _$BitcoinAddressError_MalformedWitnessVersionImpl;
}

/// @nodoc
abstract class _$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWith<
    $Res> {
  factory _$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWith(
          _$BitcoinAddressError_InvalidWitnessProgramLengthImpl value,
          $Res Function(_$BitcoinAddressError_InvalidWitnessProgramLengthImpl)
              then) =
      __$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_InvalidWitnessProgramLengthImpl>
    implements
        _$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWith<$Res> {
  __$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWithImpl(
      _$BitcoinAddressError_InvalidWitnessProgramLengthImpl _value,
      $Res Function(_$BitcoinAddressError_InvalidWitnessProgramLengthImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinAddressError_InvalidWitnessProgramLengthImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_InvalidWitnessProgramLengthImpl
    implements BitcoinAddressError_InvalidWitnessProgramLength {
  const _$BitcoinAddressError_InvalidWitnessProgramLengthImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'BitcoinAddressError.invalidWitnessProgramLength(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_InvalidWitnessProgramLengthImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWith<
          _$BitcoinAddressError_InvalidWitnessProgramLengthImpl>
      get copyWith =>
          __$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWithImpl<
                  _$BitcoinAddressError_InvalidWitnessProgramLengthImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return invalidWitnessProgramLength(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return invalidWitnessProgramLength?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (invalidWitnessProgramLength != null) {
      return invalidWitnessProgramLength(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return invalidWitnessProgramLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return invalidWitnessProgramLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (invalidWitnessProgramLength != null) {
      return invalidWitnessProgramLength(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_InvalidWitnessProgramLength
    implements BitcoinAddressError {
  const factory BitcoinAddressError_InvalidWitnessProgramLength(
      final int field0) = _$BitcoinAddressError_InvalidWitnessProgramLengthImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_InvalidWitnessProgramLengthImplCopyWith<
          _$BitcoinAddressError_InvalidWitnessProgramLengthImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWith<
    $Res> {
  factory _$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWith(
          _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl value,
          $Res Function(_$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl)
              then) =
      __$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWithImpl<
          $Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl>
    implements
        _$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWith<$Res> {
  __$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWithImpl(
      _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl _value,
      $Res Function(_$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl
    implements BitcoinAddressError_InvalidSegwitV0ProgramLength {
  const _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'BitcoinAddressError.invalidSegwitV0ProgramLength(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWith<
          _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl>
      get copyWith =>
          __$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWithImpl<
                  _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return invalidSegwitV0ProgramLength(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return invalidSegwitV0ProgramLength?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (invalidSegwitV0ProgramLength != null) {
      return invalidSegwitV0ProgramLength(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return invalidSegwitV0ProgramLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return invalidSegwitV0ProgramLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (invalidSegwitV0ProgramLength != null) {
      return invalidSegwitV0ProgramLength(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_InvalidSegwitV0ProgramLength
    implements BitcoinAddressError {
  const factory BitcoinAddressError_InvalidSegwitV0ProgramLength(
          final int field0) =
      _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_InvalidSegwitV0ProgramLengthImplCopyWith<
          _$BitcoinAddressError_InvalidSegwitV0ProgramLengthImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinAddressError_UncompressedPubkeyImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_UncompressedPubkeyImplCopyWith(
          _$BitcoinAddressError_UncompressedPubkeyImpl value,
          $Res Function(_$BitcoinAddressError_UncompressedPubkeyImpl) then) =
      __$$BitcoinAddressError_UncompressedPubkeyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BitcoinAddressError_UncompressedPubkeyImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_UncompressedPubkeyImpl>
    implements _$$BitcoinAddressError_UncompressedPubkeyImplCopyWith<$Res> {
  __$$BitcoinAddressError_UncompressedPubkeyImplCopyWithImpl(
      _$BitcoinAddressError_UncompressedPubkeyImpl _value,
      $Res Function(_$BitcoinAddressError_UncompressedPubkeyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BitcoinAddressError_UncompressedPubkeyImpl
    implements BitcoinAddressError_UncompressedPubkey {
  const _$BitcoinAddressError_UncompressedPubkeyImpl();

  @override
  String toString() {
    return 'BitcoinAddressError.uncompressedPubkey()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_UncompressedPubkeyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return uncompressedPubkey();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return uncompressedPubkey?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (uncompressedPubkey != null) {
      return uncompressedPubkey();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return uncompressedPubkey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return uncompressedPubkey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (uncompressedPubkey != null) {
      return uncompressedPubkey(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_UncompressedPubkey
    implements BitcoinAddressError {
  const factory BitcoinAddressError_UncompressedPubkey() =
      _$BitcoinAddressError_UncompressedPubkeyImpl;
}

/// @nodoc
abstract class _$$BitcoinAddressError_ExcessiveScriptSizeImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_ExcessiveScriptSizeImplCopyWith(
          _$BitcoinAddressError_ExcessiveScriptSizeImpl value,
          $Res Function(_$BitcoinAddressError_ExcessiveScriptSizeImpl) then) =
      __$$BitcoinAddressError_ExcessiveScriptSizeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BitcoinAddressError_ExcessiveScriptSizeImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_ExcessiveScriptSizeImpl>
    implements _$$BitcoinAddressError_ExcessiveScriptSizeImplCopyWith<$Res> {
  __$$BitcoinAddressError_ExcessiveScriptSizeImplCopyWithImpl(
      _$BitcoinAddressError_ExcessiveScriptSizeImpl _value,
      $Res Function(_$BitcoinAddressError_ExcessiveScriptSizeImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BitcoinAddressError_ExcessiveScriptSizeImpl
    implements BitcoinAddressError_ExcessiveScriptSize {
  const _$BitcoinAddressError_ExcessiveScriptSizeImpl();

  @override
  String toString() {
    return 'BitcoinAddressError.excessiveScriptSize()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_ExcessiveScriptSizeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return excessiveScriptSize();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return excessiveScriptSize?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (excessiveScriptSize != null) {
      return excessiveScriptSize();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return excessiveScriptSize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return excessiveScriptSize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (excessiveScriptSize != null) {
      return excessiveScriptSize(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_ExcessiveScriptSize
    implements BitcoinAddressError {
  const factory BitcoinAddressError_ExcessiveScriptSize() =
      _$BitcoinAddressError_ExcessiveScriptSizeImpl;
}

/// @nodoc
abstract class _$$BitcoinAddressError_UnrecognizedScriptImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_UnrecognizedScriptImplCopyWith(
          _$BitcoinAddressError_UnrecognizedScriptImpl value,
          $Res Function(_$BitcoinAddressError_UnrecognizedScriptImpl) then) =
      __$$BitcoinAddressError_UnrecognizedScriptImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BitcoinAddressError_UnrecognizedScriptImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_UnrecognizedScriptImpl>
    implements _$$BitcoinAddressError_UnrecognizedScriptImplCopyWith<$Res> {
  __$$BitcoinAddressError_UnrecognizedScriptImplCopyWithImpl(
      _$BitcoinAddressError_UnrecognizedScriptImpl _value,
      $Res Function(_$BitcoinAddressError_UnrecognizedScriptImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BitcoinAddressError_UnrecognizedScriptImpl
    implements BitcoinAddressError_UnrecognizedScript {
  const _$BitcoinAddressError_UnrecognizedScriptImpl();

  @override
  String toString() {
    return 'BitcoinAddressError.unrecognizedScript()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_UnrecognizedScriptImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return unrecognizedScript();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return unrecognizedScript?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (unrecognizedScript != null) {
      return unrecognizedScript();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return unrecognizedScript(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return unrecognizedScript?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (unrecognizedScript != null) {
      return unrecognizedScript(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_UnrecognizedScript
    implements BitcoinAddressError {
  const factory BitcoinAddressError_UnrecognizedScript() =
      _$BitcoinAddressError_UnrecognizedScriptImpl;
}

/// @nodoc
abstract class _$$BitcoinAddressError_UnknownAddressTypeImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_UnknownAddressTypeImplCopyWith(
          _$BitcoinAddressError_UnknownAddressTypeImpl value,
          $Res Function(_$BitcoinAddressError_UnknownAddressTypeImpl) then) =
      __$$BitcoinAddressError_UnknownAddressTypeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BitcoinAddressError_UnknownAddressTypeImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_UnknownAddressTypeImpl>
    implements _$$BitcoinAddressError_UnknownAddressTypeImplCopyWith<$Res> {
  __$$BitcoinAddressError_UnknownAddressTypeImplCopyWithImpl(
      _$BitcoinAddressError_UnknownAddressTypeImpl _value,
      $Res Function(_$BitcoinAddressError_UnknownAddressTypeImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinAddressError_UnknownAddressTypeImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_UnknownAddressTypeImpl
    implements BitcoinAddressError_UnknownAddressType {
  const _$BitcoinAddressError_UnknownAddressTypeImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'BitcoinAddressError.unknownAddressType(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_UnknownAddressTypeImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_UnknownAddressTypeImplCopyWith<
          _$BitcoinAddressError_UnknownAddressTypeImpl>
      get copyWith =>
          __$$BitcoinAddressError_UnknownAddressTypeImplCopyWithImpl<
              _$BitcoinAddressError_UnknownAddressTypeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return unknownAddressType(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return unknownAddressType?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (unknownAddressType != null) {
      return unknownAddressType(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return unknownAddressType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return unknownAddressType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (unknownAddressType != null) {
      return unknownAddressType(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_UnknownAddressType
    implements BitcoinAddressError {
  const factory BitcoinAddressError_UnknownAddressType(final String field0) =
      _$BitcoinAddressError_UnknownAddressTypeImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_UnknownAddressTypeImplCopyWith<
          _$BitcoinAddressError_UnknownAddressTypeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinAddressError_NetworkValidationImplCopyWith<$Res> {
  factory _$$BitcoinAddressError_NetworkValidationImplCopyWith(
          _$BitcoinAddressError_NetworkValidationImpl value,
          $Res Function(_$BitcoinAddressError_NetworkValidationImpl) then) =
      __$$BitcoinAddressError_NetworkValidationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Network networkRequired, Network networkFound, String address});
}

/// @nodoc
class __$$BitcoinAddressError_NetworkValidationImplCopyWithImpl<$Res>
    extends _$BitcoinAddressErrorCopyWithImpl<$Res,
        _$BitcoinAddressError_NetworkValidationImpl>
    implements _$$BitcoinAddressError_NetworkValidationImplCopyWith<$Res> {
  __$$BitcoinAddressError_NetworkValidationImplCopyWithImpl(
      _$BitcoinAddressError_NetworkValidationImpl _value,
      $Res Function(_$BitcoinAddressError_NetworkValidationImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? networkRequired = null,
    Object? networkFound = null,
    Object? address = null,
  }) {
    return _then(_$BitcoinAddressError_NetworkValidationImpl(
      networkRequired: null == networkRequired
          ? _value.networkRequired
          : networkRequired // ignore: cast_nullable_to_non_nullable
              as Network,
      networkFound: null == networkFound
          ? _value.networkFound
          : networkFound // ignore: cast_nullable_to_non_nullable
              as Network,
      address: null == address
          ? _value.address
          : address // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BitcoinAddressError_NetworkValidationImpl
    implements BitcoinAddressError_NetworkValidation {
  const _$BitcoinAddressError_NetworkValidationImpl(
      {required this.networkRequired,
      required this.networkFound,
      required this.address});

  @override
  final Network networkRequired;
  @override
  final Network networkFound;
  @override
  final String address;

  @override
  String toString() {
    return 'BitcoinAddressError.networkValidation(networkRequired: $networkRequired, networkFound: $networkFound, address: $address)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinAddressError_NetworkValidationImpl &&
            (identical(other.networkRequired, networkRequired) ||
                other.networkRequired == networkRequired) &&
            (identical(other.networkFound, networkFound) ||
                other.networkFound == networkFound) &&
            (identical(other.address, address) || other.address == address));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, networkRequired, networkFound, address);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinAddressError_NetworkValidationImplCopyWith<
          _$BitcoinAddressError_NetworkValidationImpl>
      get copyWith => __$$BitcoinAddressError_NetworkValidationImplCopyWithImpl<
          _$BitcoinAddressError_NetworkValidationImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) base58,
    required TResult Function(String field0) bech32,
    required TResult Function() emptyBech32Payload,
    required TResult Function(Variant expected, Variant found)
        invalidBech32Variant,
    required TResult Function(int field0) invalidWitnessVersion,
    required TResult Function(String field0) unparsableWitnessVersion,
    required TResult Function() malformedWitnessVersion,
    required TResult Function(int field0) invalidWitnessProgramLength,
    required TResult Function(int field0) invalidSegwitV0ProgramLength,
    required TResult Function() uncompressedPubkey,
    required TResult Function() excessiveScriptSize,
    required TResult Function() unrecognizedScript,
    required TResult Function(String field0) unknownAddressType,
    required TResult Function(
            Network networkRequired, Network networkFound, String address)
        networkValidation,
  }) {
    return networkValidation(networkRequired, networkFound, address);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? base58,
    TResult? Function(String field0)? bech32,
    TResult? Function()? emptyBech32Payload,
    TResult? Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult? Function(int field0)? invalidWitnessVersion,
    TResult? Function(String field0)? unparsableWitnessVersion,
    TResult? Function()? malformedWitnessVersion,
    TResult? Function(int field0)? invalidWitnessProgramLength,
    TResult? Function(int field0)? invalidSegwitV0ProgramLength,
    TResult? Function()? uncompressedPubkey,
    TResult? Function()? excessiveScriptSize,
    TResult? Function()? unrecognizedScript,
    TResult? Function(String field0)? unknownAddressType,
    TResult? Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
  }) {
    return networkValidation?.call(networkRequired, networkFound, address);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? base58,
    TResult Function(String field0)? bech32,
    TResult Function()? emptyBech32Payload,
    TResult Function(Variant expected, Variant found)? invalidBech32Variant,
    TResult Function(int field0)? invalidWitnessVersion,
    TResult Function(String field0)? unparsableWitnessVersion,
    TResult Function()? malformedWitnessVersion,
    TResult Function(int field0)? invalidWitnessProgramLength,
    TResult Function(int field0)? invalidSegwitV0ProgramLength,
    TResult Function()? uncompressedPubkey,
    TResult Function()? excessiveScriptSize,
    TResult Function()? unrecognizedScript,
    TResult Function(String field0)? unknownAddressType,
    TResult Function(
            Network networkRequired, Network networkFound, String address)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (networkValidation != null) {
      return networkValidation(networkRequired, networkFound, address);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinAddressError_Base58 value) base58,
    required TResult Function(BitcoinAddressError_Bech32 value) bech32,
    required TResult Function(BitcoinAddressError_EmptyBech32Payload value)
        emptyBech32Payload,
    required TResult Function(BitcoinAddressError_InvalidBech32Variant value)
        invalidBech32Variant,
    required TResult Function(BitcoinAddressError_InvalidWitnessVersion value)
        invalidWitnessVersion,
    required TResult Function(
            BitcoinAddressError_UnparsableWitnessVersion value)
        unparsableWitnessVersion,
    required TResult Function(BitcoinAddressError_MalformedWitnessVersion value)
        malformedWitnessVersion,
    required TResult Function(
            BitcoinAddressError_InvalidWitnessProgramLength value)
        invalidWitnessProgramLength,
    required TResult Function(
            BitcoinAddressError_InvalidSegwitV0ProgramLength value)
        invalidSegwitV0ProgramLength,
    required TResult Function(BitcoinAddressError_UncompressedPubkey value)
        uncompressedPubkey,
    required TResult Function(BitcoinAddressError_ExcessiveScriptSize value)
        excessiveScriptSize,
    required TResult Function(BitcoinAddressError_UnrecognizedScript value)
        unrecognizedScript,
    required TResult Function(BitcoinAddressError_UnknownAddressType value)
        unknownAddressType,
    required TResult Function(BitcoinAddressError_NetworkValidation value)
        networkValidation,
  }) {
    return networkValidation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinAddressError_Base58 value)? base58,
    TResult? Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult? Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult? Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult? Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult? Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult? Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult? Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult? Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult? Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult? Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult? Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult? Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult? Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
  }) {
    return networkValidation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinAddressError_Base58 value)? base58,
    TResult Function(BitcoinAddressError_Bech32 value)? bech32,
    TResult Function(BitcoinAddressError_EmptyBech32Payload value)?
        emptyBech32Payload,
    TResult Function(BitcoinAddressError_InvalidBech32Variant value)?
        invalidBech32Variant,
    TResult Function(BitcoinAddressError_InvalidWitnessVersion value)?
        invalidWitnessVersion,
    TResult Function(BitcoinAddressError_UnparsableWitnessVersion value)?
        unparsableWitnessVersion,
    TResult Function(BitcoinAddressError_MalformedWitnessVersion value)?
        malformedWitnessVersion,
    TResult Function(BitcoinAddressError_InvalidWitnessProgramLength value)?
        invalidWitnessProgramLength,
    TResult Function(BitcoinAddressError_InvalidSegwitV0ProgramLength value)?
        invalidSegwitV0ProgramLength,
    TResult Function(BitcoinAddressError_UncompressedPubkey value)?
        uncompressedPubkey,
    TResult Function(BitcoinAddressError_ExcessiveScriptSize value)?
        excessiveScriptSize,
    TResult Function(BitcoinAddressError_UnrecognizedScript value)?
        unrecognizedScript,
    TResult Function(BitcoinAddressError_UnknownAddressType value)?
        unknownAddressType,
    TResult Function(BitcoinAddressError_NetworkValidation value)?
        networkValidation,
    required TResult orElse(),
  }) {
    if (networkValidation != null) {
      return networkValidation(this);
    }
    return orElse();
  }
}

abstract class BitcoinAddressError_NetworkValidation
    implements BitcoinAddressError {
  const factory BitcoinAddressError_NetworkValidation(
          {required final Network networkRequired,
          required final Network networkFound,
          required final String address}) =
      _$BitcoinAddressError_NetworkValidationImpl;

  Network get networkRequired;
  Network get networkFound;
  String get address;
  @JsonKey(ignore: true)
  _$$BitcoinAddressError_NetworkValidationImplCopyWith<
          _$BitcoinAddressError_NetworkValidationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BitcoinConsensusError {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) io,
    required TResult Function(int requested, int max) oversizedVectorAllocation,
    required TResult Function(U8Array4 expected, U8Array4 actual)
        invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function(String field0) parseFailed,
    required TResult Function(int field0) unsupportedSegwitFlag,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? io,
    TResult? Function(int requested, int max)? oversizedVectorAllocation,
    TResult? Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function(String field0)? parseFailed,
    TResult? Function(int field0)? unsupportedSegwitFlag,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? io,
    TResult Function(int requested, int max)? oversizedVectorAllocation,
    TResult Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function(String field0)? parseFailed,
    TResult Function(int field0)? unsupportedSegwitFlag,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinConsensusError_Io value) io,
    required TResult Function(
            BitcoinConsensusError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(BitcoinConsensusError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(BitcoinConsensusError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(BitcoinConsensusError_ParseFailed value)
        parseFailed,
    required TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinConsensusError_Io value)? io,
    TResult? Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult? Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult? Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinConsensusError_Io value)? io,
    TResult Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BitcoinConsensusErrorCopyWith<$Res> {
  factory $BitcoinConsensusErrorCopyWith(BitcoinConsensusError value,
          $Res Function(BitcoinConsensusError) then) =
      _$BitcoinConsensusErrorCopyWithImpl<$Res, BitcoinConsensusError>;
}

/// @nodoc
class _$BitcoinConsensusErrorCopyWithImpl<$Res,
        $Val extends BitcoinConsensusError>
    implements $BitcoinConsensusErrorCopyWith<$Res> {
  _$BitcoinConsensusErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$BitcoinConsensusError_IoImplCopyWith<$Res> {
  factory _$$BitcoinConsensusError_IoImplCopyWith(
          _$BitcoinConsensusError_IoImpl value,
          $Res Function(_$BitcoinConsensusError_IoImpl) then) =
      __$$BitcoinConsensusError_IoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BitcoinConsensusError_IoImplCopyWithImpl<$Res>
    extends _$BitcoinConsensusErrorCopyWithImpl<$Res,
        _$BitcoinConsensusError_IoImpl>
    implements _$$BitcoinConsensusError_IoImplCopyWith<$Res> {
  __$$BitcoinConsensusError_IoImplCopyWithImpl(
      _$BitcoinConsensusError_IoImpl _value,
      $Res Function(_$BitcoinConsensusError_IoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinConsensusError_IoImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BitcoinConsensusError_IoImpl implements BitcoinConsensusError_Io {
  const _$BitcoinConsensusError_IoImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'BitcoinConsensusError.io(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinConsensusError_IoImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinConsensusError_IoImplCopyWith<_$BitcoinConsensusError_IoImpl>
      get copyWith => __$$BitcoinConsensusError_IoImplCopyWithImpl<
          _$BitcoinConsensusError_IoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) io,
    required TResult Function(int requested, int max) oversizedVectorAllocation,
    required TResult Function(U8Array4 expected, U8Array4 actual)
        invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function(String field0) parseFailed,
    required TResult Function(int field0) unsupportedSegwitFlag,
  }) {
    return io(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? io,
    TResult? Function(int requested, int max)? oversizedVectorAllocation,
    TResult? Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function(String field0)? parseFailed,
    TResult? Function(int field0)? unsupportedSegwitFlag,
  }) {
    return io?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? io,
    TResult Function(int requested, int max)? oversizedVectorAllocation,
    TResult Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function(String field0)? parseFailed,
    TResult Function(int field0)? unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (io != null) {
      return io(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinConsensusError_Io value) io,
    required TResult Function(
            BitcoinConsensusError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(BitcoinConsensusError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(BitcoinConsensusError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(BitcoinConsensusError_ParseFailed value)
        parseFailed,
    required TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
  }) {
    return io(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinConsensusError_Io value)? io,
    TResult? Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult? Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult? Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
  }) {
    return io?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinConsensusError_Io value)? io,
    TResult Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (io != null) {
      return io(this);
    }
    return orElse();
  }
}

abstract class BitcoinConsensusError_Io implements BitcoinConsensusError {
  const factory BitcoinConsensusError_Io(final String field0) =
      _$BitcoinConsensusError_IoImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$BitcoinConsensusError_IoImplCopyWith<_$BitcoinConsensusError_IoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWith<
    $Res> {
  factory _$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWith(
          _$BitcoinConsensusError_OversizedVectorAllocationImpl value,
          $Res Function(_$BitcoinConsensusError_OversizedVectorAllocationImpl)
              then) =
      __$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int requested, int max});
}

/// @nodoc
class __$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWithImpl<$Res>
    extends _$BitcoinConsensusErrorCopyWithImpl<$Res,
        _$BitcoinConsensusError_OversizedVectorAllocationImpl>
    implements
        _$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWith<$Res> {
  __$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWithImpl(
      _$BitcoinConsensusError_OversizedVectorAllocationImpl _value,
      $Res Function(_$BitcoinConsensusError_OversizedVectorAllocationImpl)
          _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? requested = null,
    Object? max = null,
  }) {
    return _then(_$BitcoinConsensusError_OversizedVectorAllocationImpl(
      requested: null == requested
          ? _value.requested
          : requested // ignore: cast_nullable_to_non_nullable
              as int,
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BitcoinConsensusError_OversizedVectorAllocationImpl
    implements BitcoinConsensusError_OversizedVectorAllocation {
  const _$BitcoinConsensusError_OversizedVectorAllocationImpl(
      {required this.requested, required this.max});

  @override
  final int requested;
  @override
  final int max;

  @override
  String toString() {
    return 'BitcoinConsensusError.oversizedVectorAllocation(requested: $requested, max: $max)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinConsensusError_OversizedVectorAllocationImpl &&
            (identical(other.requested, requested) ||
                other.requested == requested) &&
            (identical(other.max, max) || other.max == max));
  }

  @override
  int get hashCode => Object.hash(runtimeType, requested, max);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWith<
          _$BitcoinConsensusError_OversizedVectorAllocationImpl>
      get copyWith =>
          __$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWithImpl<
                  _$BitcoinConsensusError_OversizedVectorAllocationImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) io,
    required TResult Function(int requested, int max) oversizedVectorAllocation,
    required TResult Function(U8Array4 expected, U8Array4 actual)
        invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function(String field0) parseFailed,
    required TResult Function(int field0) unsupportedSegwitFlag,
  }) {
    return oversizedVectorAllocation(requested, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? io,
    TResult? Function(int requested, int max)? oversizedVectorAllocation,
    TResult? Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function(String field0)? parseFailed,
    TResult? Function(int field0)? unsupportedSegwitFlag,
  }) {
    return oversizedVectorAllocation?.call(requested, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? io,
    TResult Function(int requested, int max)? oversizedVectorAllocation,
    TResult Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function(String field0)? parseFailed,
    TResult Function(int field0)? unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (oversizedVectorAllocation != null) {
      return oversizedVectorAllocation(requested, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinConsensusError_Io value) io,
    required TResult Function(
            BitcoinConsensusError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(BitcoinConsensusError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(BitcoinConsensusError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(BitcoinConsensusError_ParseFailed value)
        parseFailed,
    required TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
  }) {
    return oversizedVectorAllocation(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinConsensusError_Io value)? io,
    TResult? Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult? Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult? Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
  }) {
    return oversizedVectorAllocation?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinConsensusError_Io value)? io,
    TResult Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (oversizedVectorAllocation != null) {
      return oversizedVectorAllocation(this);
    }
    return orElse();
  }
}

abstract class BitcoinConsensusError_OversizedVectorAllocation
    implements BitcoinConsensusError {
  const factory BitcoinConsensusError_OversizedVectorAllocation(
          {required final int requested, required final int max}) =
      _$BitcoinConsensusError_OversizedVectorAllocationImpl;

  int get requested;
  int get max;
  @JsonKey(ignore: true)
  _$$BitcoinConsensusError_OversizedVectorAllocationImplCopyWith<
          _$BitcoinConsensusError_OversizedVectorAllocationImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinConsensusError_InvalidChecksumImplCopyWith<$Res> {
  factory _$$BitcoinConsensusError_InvalidChecksumImplCopyWith(
          _$BitcoinConsensusError_InvalidChecksumImpl value,
          $Res Function(_$BitcoinConsensusError_InvalidChecksumImpl) then) =
      __$$BitcoinConsensusError_InvalidChecksumImplCopyWithImpl<$Res>;
  @useResult
  $Res call({U8Array4 expected, U8Array4 actual});
}

/// @nodoc
class __$$BitcoinConsensusError_InvalidChecksumImplCopyWithImpl<$Res>
    extends _$BitcoinConsensusErrorCopyWithImpl<$Res,
        _$BitcoinConsensusError_InvalidChecksumImpl>
    implements _$$BitcoinConsensusError_InvalidChecksumImplCopyWith<$Res> {
  __$$BitcoinConsensusError_InvalidChecksumImplCopyWithImpl(
      _$BitcoinConsensusError_InvalidChecksumImpl _value,
      $Res Function(_$BitcoinConsensusError_InvalidChecksumImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
    Object? actual = null,
  }) {
    return _then(_$BitcoinConsensusError_InvalidChecksumImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as U8Array4,
      actual: null == actual
          ? _value.actual
          : actual // ignore: cast_nullable_to_non_nullable
              as U8Array4,
    ));
  }
}

/// @nodoc

class _$BitcoinConsensusError_InvalidChecksumImpl
    implements BitcoinConsensusError_InvalidChecksum {
  const _$BitcoinConsensusError_InvalidChecksumImpl(
      {required this.expected, required this.actual});

  @override
  final U8Array4 expected;
  @override
  final U8Array4 actual;

  @override
  String toString() {
    return 'BitcoinConsensusError.invalidChecksum(expected: $expected, actual: $actual)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinConsensusError_InvalidChecksumImpl &&
            const DeepCollectionEquality().equals(other.expected, expected) &&
            const DeepCollectionEquality().equals(other.actual, actual));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(expected),
      const DeepCollectionEquality().hash(actual));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinConsensusError_InvalidChecksumImplCopyWith<
          _$BitcoinConsensusError_InvalidChecksumImpl>
      get copyWith => __$$BitcoinConsensusError_InvalidChecksumImplCopyWithImpl<
          _$BitcoinConsensusError_InvalidChecksumImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) io,
    required TResult Function(int requested, int max) oversizedVectorAllocation,
    required TResult Function(U8Array4 expected, U8Array4 actual)
        invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function(String field0) parseFailed,
    required TResult Function(int field0) unsupportedSegwitFlag,
  }) {
    return invalidChecksum(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? io,
    TResult? Function(int requested, int max)? oversizedVectorAllocation,
    TResult? Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function(String field0)? parseFailed,
    TResult? Function(int field0)? unsupportedSegwitFlag,
  }) {
    return invalidChecksum?.call(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? io,
    TResult Function(int requested, int max)? oversizedVectorAllocation,
    TResult Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function(String field0)? parseFailed,
    TResult Function(int field0)? unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (invalidChecksum != null) {
      return invalidChecksum(expected, actual);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinConsensusError_Io value) io,
    required TResult Function(
            BitcoinConsensusError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(BitcoinConsensusError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(BitcoinConsensusError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(BitcoinConsensusError_ParseFailed value)
        parseFailed,
    required TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
  }) {
    return invalidChecksum(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinConsensusError_Io value)? io,
    TResult? Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult? Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult? Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
  }) {
    return invalidChecksum?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinConsensusError_Io value)? io,
    TResult Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (invalidChecksum != null) {
      return invalidChecksum(this);
    }
    return orElse();
  }
}

abstract class BitcoinConsensusError_InvalidChecksum
    implements BitcoinConsensusError {
  const factory BitcoinConsensusError_InvalidChecksum(
          {required final U8Array4 expected, required final U8Array4 actual}) =
      _$BitcoinConsensusError_InvalidChecksumImpl;

  U8Array4 get expected;
  U8Array4 get actual;
  @JsonKey(ignore: true)
  _$$BitcoinConsensusError_InvalidChecksumImplCopyWith<
          _$BitcoinConsensusError_InvalidChecksumImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinConsensusError_NonMinimalVarIntImplCopyWith<$Res> {
  factory _$$BitcoinConsensusError_NonMinimalVarIntImplCopyWith(
          _$BitcoinConsensusError_NonMinimalVarIntImpl value,
          $Res Function(_$BitcoinConsensusError_NonMinimalVarIntImpl) then) =
      __$$BitcoinConsensusError_NonMinimalVarIntImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BitcoinConsensusError_NonMinimalVarIntImplCopyWithImpl<$Res>
    extends _$BitcoinConsensusErrorCopyWithImpl<$Res,
        _$BitcoinConsensusError_NonMinimalVarIntImpl>
    implements _$$BitcoinConsensusError_NonMinimalVarIntImplCopyWith<$Res> {
  __$$BitcoinConsensusError_NonMinimalVarIntImplCopyWithImpl(
      _$BitcoinConsensusError_NonMinimalVarIntImpl _value,
      $Res Function(_$BitcoinConsensusError_NonMinimalVarIntImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BitcoinConsensusError_NonMinimalVarIntImpl
    implements BitcoinConsensusError_NonMinimalVarInt {
  const _$BitcoinConsensusError_NonMinimalVarIntImpl();

  @override
  String toString() {
    return 'BitcoinConsensusError.nonMinimalVarInt()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinConsensusError_NonMinimalVarIntImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) io,
    required TResult Function(int requested, int max) oversizedVectorAllocation,
    required TResult Function(U8Array4 expected, U8Array4 actual)
        invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function(String field0) parseFailed,
    required TResult Function(int field0) unsupportedSegwitFlag,
  }) {
    return nonMinimalVarInt();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? io,
    TResult? Function(int requested, int max)? oversizedVectorAllocation,
    TResult? Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function(String field0)? parseFailed,
    TResult? Function(int field0)? unsupportedSegwitFlag,
  }) {
    return nonMinimalVarInt?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? io,
    TResult Function(int requested, int max)? oversizedVectorAllocation,
    TResult Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function(String field0)? parseFailed,
    TResult Function(int field0)? unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (nonMinimalVarInt != null) {
      return nonMinimalVarInt();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinConsensusError_Io value) io,
    required TResult Function(
            BitcoinConsensusError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(BitcoinConsensusError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(BitcoinConsensusError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(BitcoinConsensusError_ParseFailed value)
        parseFailed,
    required TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
  }) {
    return nonMinimalVarInt(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinConsensusError_Io value)? io,
    TResult? Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult? Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult? Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
  }) {
    return nonMinimalVarInt?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinConsensusError_Io value)? io,
    TResult Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (nonMinimalVarInt != null) {
      return nonMinimalVarInt(this);
    }
    return orElse();
  }
}

abstract class BitcoinConsensusError_NonMinimalVarInt
    implements BitcoinConsensusError {
  const factory BitcoinConsensusError_NonMinimalVarInt() =
      _$BitcoinConsensusError_NonMinimalVarIntImpl;
}

/// @nodoc
abstract class _$$BitcoinConsensusError_ParseFailedImplCopyWith<$Res> {
  factory _$$BitcoinConsensusError_ParseFailedImplCopyWith(
          _$BitcoinConsensusError_ParseFailedImpl value,
          $Res Function(_$BitcoinConsensusError_ParseFailedImpl) then) =
      __$$BitcoinConsensusError_ParseFailedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String field0});
}

/// @nodoc
class __$$BitcoinConsensusError_ParseFailedImplCopyWithImpl<$Res>
    extends _$BitcoinConsensusErrorCopyWithImpl<$Res,
        _$BitcoinConsensusError_ParseFailedImpl>
    implements _$$BitcoinConsensusError_ParseFailedImplCopyWith<$Res> {
  __$$BitcoinConsensusError_ParseFailedImplCopyWithImpl(
      _$BitcoinConsensusError_ParseFailedImpl _value,
      $Res Function(_$BitcoinConsensusError_ParseFailedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinConsensusError_ParseFailedImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$BitcoinConsensusError_ParseFailedImpl
    implements BitcoinConsensusError_ParseFailed {
  const _$BitcoinConsensusError_ParseFailedImpl(this.field0);

  @override
  final String field0;

  @override
  String toString() {
    return 'BitcoinConsensusError.parseFailed(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinConsensusError_ParseFailedImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinConsensusError_ParseFailedImplCopyWith<
          _$BitcoinConsensusError_ParseFailedImpl>
      get copyWith => __$$BitcoinConsensusError_ParseFailedImplCopyWithImpl<
          _$BitcoinConsensusError_ParseFailedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) io,
    required TResult Function(int requested, int max) oversizedVectorAllocation,
    required TResult Function(U8Array4 expected, U8Array4 actual)
        invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function(String field0) parseFailed,
    required TResult Function(int field0) unsupportedSegwitFlag,
  }) {
    return parseFailed(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? io,
    TResult? Function(int requested, int max)? oversizedVectorAllocation,
    TResult? Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function(String field0)? parseFailed,
    TResult? Function(int field0)? unsupportedSegwitFlag,
  }) {
    return parseFailed?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? io,
    TResult Function(int requested, int max)? oversizedVectorAllocation,
    TResult Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function(String field0)? parseFailed,
    TResult Function(int field0)? unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (parseFailed != null) {
      return parseFailed(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinConsensusError_Io value) io,
    required TResult Function(
            BitcoinConsensusError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(BitcoinConsensusError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(BitcoinConsensusError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(BitcoinConsensusError_ParseFailed value)
        parseFailed,
    required TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
  }) {
    return parseFailed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinConsensusError_Io value)? io,
    TResult? Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult? Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult? Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
  }) {
    return parseFailed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinConsensusError_Io value)? io,
    TResult Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (parseFailed != null) {
      return parseFailed(this);
    }
    return orElse();
  }
}

abstract class BitcoinConsensusError_ParseFailed
    implements BitcoinConsensusError {
  const factory BitcoinConsensusError_ParseFailed(final String field0) =
      _$BitcoinConsensusError_ParseFailedImpl;

  String get field0;
  @JsonKey(ignore: true)
  _$$BitcoinConsensusError_ParseFailedImplCopyWith<
          _$BitcoinConsensusError_ParseFailedImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWith<
    $Res> {
  factory _$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWith(
          _$BitcoinConsensusError_UnsupportedSegwitFlagImpl value,
          $Res Function(_$BitcoinConsensusError_UnsupportedSegwitFlagImpl)
              then) =
      __$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWithImpl<$Res>
    extends _$BitcoinConsensusErrorCopyWithImpl<$Res,
        _$BitcoinConsensusError_UnsupportedSegwitFlagImpl>
    implements
        _$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWith<$Res> {
  __$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWithImpl(
      _$BitcoinConsensusError_UnsupportedSegwitFlagImpl _value,
      $Res Function(_$BitcoinConsensusError_UnsupportedSegwitFlagImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinConsensusError_UnsupportedSegwitFlagImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BitcoinConsensusError_UnsupportedSegwitFlagImpl
    implements BitcoinConsensusError_UnsupportedSegwitFlag {
  const _$BitcoinConsensusError_UnsupportedSegwitFlagImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'BitcoinConsensusError.unsupportedSegwitFlag(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinConsensusError_UnsupportedSegwitFlagImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWith<
          _$BitcoinConsensusError_UnsupportedSegwitFlagImpl>
      get copyWith =>
          __$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWithImpl<
                  _$BitcoinConsensusError_UnsupportedSegwitFlagImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String field0) io,
    required TResult Function(int requested, int max) oversizedVectorAllocation,
    required TResult Function(U8Array4 expected, U8Array4 actual)
        invalidChecksum,
    required TResult Function() nonMinimalVarInt,
    required TResult Function(String field0) parseFailed,
    required TResult Function(int field0) unsupportedSegwitFlag,
  }) {
    return unsupportedSegwitFlag(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String field0)? io,
    TResult? Function(int requested, int max)? oversizedVectorAllocation,
    TResult? Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult? Function()? nonMinimalVarInt,
    TResult? Function(String field0)? parseFailed,
    TResult? Function(int field0)? unsupportedSegwitFlag,
  }) {
    return unsupportedSegwitFlag?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String field0)? io,
    TResult Function(int requested, int max)? oversizedVectorAllocation,
    TResult Function(U8Array4 expected, U8Array4 actual)? invalidChecksum,
    TResult Function()? nonMinimalVarInt,
    TResult Function(String field0)? parseFailed,
    TResult Function(int field0)? unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (unsupportedSegwitFlag != null) {
      return unsupportedSegwitFlag(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinConsensusError_Io value) io,
    required TResult Function(
            BitcoinConsensusError_OversizedVectorAllocation value)
        oversizedVectorAllocation,
    required TResult Function(BitcoinConsensusError_InvalidChecksum value)
        invalidChecksum,
    required TResult Function(BitcoinConsensusError_NonMinimalVarInt value)
        nonMinimalVarInt,
    required TResult Function(BitcoinConsensusError_ParseFailed value)
        parseFailed,
    required TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)
        unsupportedSegwitFlag,
  }) {
    return unsupportedSegwitFlag(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinConsensusError_Io value)? io,
    TResult? Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult? Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult? Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult? Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult? Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
  }) {
    return unsupportedSegwitFlag?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinConsensusError_Io value)? io,
    TResult Function(BitcoinConsensusError_OversizedVectorAllocation value)?
        oversizedVectorAllocation,
    TResult Function(BitcoinConsensusError_InvalidChecksum value)?
        invalidChecksum,
    TResult Function(BitcoinConsensusError_NonMinimalVarInt value)?
        nonMinimalVarInt,
    TResult Function(BitcoinConsensusError_ParseFailed value)? parseFailed,
    TResult Function(BitcoinConsensusError_UnsupportedSegwitFlag value)?
        unsupportedSegwitFlag,
    required TResult orElse(),
  }) {
    if (unsupportedSegwitFlag != null) {
      return unsupportedSegwitFlag(this);
    }
    return orElse();
  }
}

abstract class BitcoinConsensusError_UnsupportedSegwitFlag
    implements BitcoinConsensusError {
  const factory BitcoinConsensusError_UnsupportedSegwitFlag(final int field0) =
      _$BitcoinConsensusError_UnsupportedSegwitFlagImpl;

  int get field0;
  @JsonKey(ignore: true)
  _$$BitcoinConsensusError_UnsupportedSegwitFlagImplCopyWith<
          _$BitcoinConsensusError_UnsupportedSegwitFlagImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BitcoinHexError {
  int get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) invalidChar,
    required TResult Function(int field0) oddLengthString,
    required TResult Function(int field0, int field1) invalidLength,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? invalidChar,
    TResult? Function(int field0)? oddLengthString,
    TResult? Function(int field0, int field1)? invalidLength,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? invalidChar,
    TResult Function(int field0)? oddLengthString,
    TResult Function(int field0, int field1)? invalidLength,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinHexError_InvalidChar value) invalidChar,
    required TResult Function(BitcoinHexError_OddLengthString value)
        oddLengthString,
    required TResult Function(BitcoinHexError_InvalidLength value)
        invalidLength,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinHexError_InvalidChar value)? invalidChar,
    TResult? Function(BitcoinHexError_OddLengthString value)? oddLengthString,
    TResult? Function(BitcoinHexError_InvalidLength value)? invalidLength,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinHexError_InvalidChar value)? invalidChar,
    TResult Function(BitcoinHexError_OddLengthString value)? oddLengthString,
    TResult Function(BitcoinHexError_InvalidLength value)? invalidLength,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BitcoinHexErrorCopyWith<BitcoinHexError> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BitcoinHexErrorCopyWith<$Res> {
  factory $BitcoinHexErrorCopyWith(
          BitcoinHexError value, $Res Function(BitcoinHexError) then) =
      _$BitcoinHexErrorCopyWithImpl<$Res, BitcoinHexError>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class _$BitcoinHexErrorCopyWithImpl<$Res, $Val extends BitcoinHexError>
    implements $BitcoinHexErrorCopyWith<$Res> {
  _$BitcoinHexErrorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BitcoinHexError_InvalidCharImplCopyWith<$Res>
    implements $BitcoinHexErrorCopyWith<$Res> {
  factory _$$BitcoinHexError_InvalidCharImplCopyWith(
          _$BitcoinHexError_InvalidCharImpl value,
          $Res Function(_$BitcoinHexError_InvalidCharImpl) then) =
      __$$BitcoinHexError_InvalidCharImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$BitcoinHexError_InvalidCharImplCopyWithImpl<$Res>
    extends _$BitcoinHexErrorCopyWithImpl<$Res,
        _$BitcoinHexError_InvalidCharImpl>
    implements _$$BitcoinHexError_InvalidCharImplCopyWith<$Res> {
  __$$BitcoinHexError_InvalidCharImplCopyWithImpl(
      _$BitcoinHexError_InvalidCharImpl _value,
      $Res Function(_$BitcoinHexError_InvalidCharImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinHexError_InvalidCharImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BitcoinHexError_InvalidCharImpl implements BitcoinHexError_InvalidChar {
  const _$BitcoinHexError_InvalidCharImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'BitcoinHexError.invalidChar(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinHexError_InvalidCharImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinHexError_InvalidCharImplCopyWith<_$BitcoinHexError_InvalidCharImpl>
      get copyWith => __$$BitcoinHexError_InvalidCharImplCopyWithImpl<
          _$BitcoinHexError_InvalidCharImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) invalidChar,
    required TResult Function(int field0) oddLengthString,
    required TResult Function(int field0, int field1) invalidLength,
  }) {
    return invalidChar(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? invalidChar,
    TResult? Function(int field0)? oddLengthString,
    TResult? Function(int field0, int field1)? invalidLength,
  }) {
    return invalidChar?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? invalidChar,
    TResult Function(int field0)? oddLengthString,
    TResult Function(int field0, int field1)? invalidLength,
    required TResult orElse(),
  }) {
    if (invalidChar != null) {
      return invalidChar(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinHexError_InvalidChar value) invalidChar,
    required TResult Function(BitcoinHexError_OddLengthString value)
        oddLengthString,
    required TResult Function(BitcoinHexError_InvalidLength value)
        invalidLength,
  }) {
    return invalidChar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinHexError_InvalidChar value)? invalidChar,
    TResult? Function(BitcoinHexError_OddLengthString value)? oddLengthString,
    TResult? Function(BitcoinHexError_InvalidLength value)? invalidLength,
  }) {
    return invalidChar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinHexError_InvalidChar value)? invalidChar,
    TResult Function(BitcoinHexError_OddLengthString value)? oddLengthString,
    TResult Function(BitcoinHexError_InvalidLength value)? invalidLength,
    required TResult orElse(),
  }) {
    if (invalidChar != null) {
      return invalidChar(this);
    }
    return orElse();
  }
}

abstract class BitcoinHexError_InvalidChar implements BitcoinHexError {
  const factory BitcoinHexError_InvalidChar(final int field0) =
      _$BitcoinHexError_InvalidCharImpl;

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$BitcoinHexError_InvalidCharImplCopyWith<_$BitcoinHexError_InvalidCharImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinHexError_OddLengthStringImplCopyWith<$Res>
    implements $BitcoinHexErrorCopyWith<$Res> {
  factory _$$BitcoinHexError_OddLengthStringImplCopyWith(
          _$BitcoinHexError_OddLengthStringImpl value,
          $Res Function(_$BitcoinHexError_OddLengthStringImpl) then) =
      __$$BitcoinHexError_OddLengthStringImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$BitcoinHexError_OddLengthStringImplCopyWithImpl<$Res>
    extends _$BitcoinHexErrorCopyWithImpl<$Res,
        _$BitcoinHexError_OddLengthStringImpl>
    implements _$$BitcoinHexError_OddLengthStringImplCopyWith<$Res> {
  __$$BitcoinHexError_OddLengthStringImplCopyWithImpl(
      _$BitcoinHexError_OddLengthStringImpl _value,
      $Res Function(_$BitcoinHexError_OddLengthStringImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$BitcoinHexError_OddLengthStringImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BitcoinHexError_OddLengthStringImpl
    implements BitcoinHexError_OddLengthString {
  const _$BitcoinHexError_OddLengthStringImpl(this.field0);

  @override
  final int field0;

  @override
  String toString() {
    return 'BitcoinHexError.oddLengthString(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinHexError_OddLengthStringImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinHexError_OddLengthStringImplCopyWith<
          _$BitcoinHexError_OddLengthStringImpl>
      get copyWith => __$$BitcoinHexError_OddLengthStringImplCopyWithImpl<
          _$BitcoinHexError_OddLengthStringImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) invalidChar,
    required TResult Function(int field0) oddLengthString,
    required TResult Function(int field0, int field1) invalidLength,
  }) {
    return oddLengthString(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? invalidChar,
    TResult? Function(int field0)? oddLengthString,
    TResult? Function(int field0, int field1)? invalidLength,
  }) {
    return oddLengthString?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? invalidChar,
    TResult Function(int field0)? oddLengthString,
    TResult Function(int field0, int field1)? invalidLength,
    required TResult orElse(),
  }) {
    if (oddLengthString != null) {
      return oddLengthString(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinHexError_InvalidChar value) invalidChar,
    required TResult Function(BitcoinHexError_OddLengthString value)
        oddLengthString,
    required TResult Function(BitcoinHexError_InvalidLength value)
        invalidLength,
  }) {
    return oddLengthString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinHexError_InvalidChar value)? invalidChar,
    TResult? Function(BitcoinHexError_OddLengthString value)? oddLengthString,
    TResult? Function(BitcoinHexError_InvalidLength value)? invalidLength,
  }) {
    return oddLengthString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinHexError_InvalidChar value)? invalidChar,
    TResult Function(BitcoinHexError_OddLengthString value)? oddLengthString,
    TResult Function(BitcoinHexError_InvalidLength value)? invalidLength,
    required TResult orElse(),
  }) {
    if (oddLengthString != null) {
      return oddLengthString(this);
    }
    return orElse();
  }
}

abstract class BitcoinHexError_OddLengthString implements BitcoinHexError {
  const factory BitcoinHexError_OddLengthString(final int field0) =
      _$BitcoinHexError_OddLengthStringImpl;

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$BitcoinHexError_OddLengthStringImplCopyWith<
          _$BitcoinHexError_OddLengthStringImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BitcoinHexError_InvalidLengthImplCopyWith<$Res>
    implements $BitcoinHexErrorCopyWith<$Res> {
  factory _$$BitcoinHexError_InvalidLengthImplCopyWith(
          _$BitcoinHexError_InvalidLengthImpl value,
          $Res Function(_$BitcoinHexError_InvalidLengthImpl) then) =
      __$$BitcoinHexError_InvalidLengthImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0, int field1});
}

/// @nodoc
class __$$BitcoinHexError_InvalidLengthImplCopyWithImpl<$Res>
    extends _$BitcoinHexErrorCopyWithImpl<$Res,
        _$BitcoinHexError_InvalidLengthImpl>
    implements _$$BitcoinHexError_InvalidLengthImplCopyWith<$Res> {
  __$$BitcoinHexError_InvalidLengthImplCopyWithImpl(
      _$BitcoinHexError_InvalidLengthImpl _value,
      $Res Function(_$BitcoinHexError_InvalidLengthImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
    Object? field1 = null,
  }) {
    return _then(_$BitcoinHexError_InvalidLengthImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
      null == field1
          ? _value.field1
          : field1 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$BitcoinHexError_InvalidLengthImpl
    implements BitcoinHexError_InvalidLength {
  const _$BitcoinHexError_InvalidLengthImpl(this.field0, this.field1);

  @override
  final int field0;
  @override
  final int field1;

  @override
  String toString() {
    return 'BitcoinHexError.invalidLength(field0: $field0, field1: $field1)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BitcoinHexError_InvalidLengthImpl &&
            (identical(other.field0, field0) || other.field0 == field0) &&
            (identical(other.field1, field1) || other.field1 == field1));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0, field1);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BitcoinHexError_InvalidLengthImplCopyWith<
          _$BitcoinHexError_InvalidLengthImpl>
      get copyWith => __$$BitcoinHexError_InvalidLengthImplCopyWithImpl<
          _$BitcoinHexError_InvalidLengthImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) invalidChar,
    required TResult Function(int field0) oddLengthString,
    required TResult Function(int field0, int field1) invalidLength,
  }) {
    return invalidLength(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? invalidChar,
    TResult? Function(int field0)? oddLengthString,
    TResult? Function(int field0, int field1)? invalidLength,
  }) {
    return invalidLength?.call(field0, field1);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? invalidChar,
    TResult Function(int field0)? oddLengthString,
    TResult Function(int field0, int field1)? invalidLength,
    required TResult orElse(),
  }) {
    if (invalidLength != null) {
      return invalidLength(field0, field1);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BitcoinHexError_InvalidChar value) invalidChar,
    required TResult Function(BitcoinHexError_OddLengthString value)
        oddLengthString,
    required TResult Function(BitcoinHexError_InvalidLength value)
        invalidLength,
  }) {
    return invalidLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BitcoinHexError_InvalidChar value)? invalidChar,
    TResult? Function(BitcoinHexError_OddLengthString value)? oddLengthString,
    TResult? Function(BitcoinHexError_InvalidLength value)? invalidLength,
  }) {
    return invalidLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BitcoinHexError_InvalidChar value)? invalidChar,
    TResult Function(BitcoinHexError_OddLengthString value)? oddLengthString,
    TResult Function(BitcoinHexError_InvalidLength value)? invalidLength,
    required TResult orElse(),
  }) {
    if (invalidLength != null) {
      return invalidLength(this);
    }
    return orElse();
  }
}

abstract class BitcoinHexError_InvalidLength implements BitcoinHexError {
  const factory BitcoinHexError_InvalidLength(
      final int field0, final int field1) = _$BitcoinHexError_InvalidLengthImpl;

  @override
  int get field0;
  int get field1;
  @override
  @JsonKey(ignore: true)
  _$$BitcoinHexError_InvalidLengthImplCopyWith<
          _$BitcoinHexError_InvalidLengthImpl>
      get copyWith => throw _privateConstructorUsedError;
}
