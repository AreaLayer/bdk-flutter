// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.25.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../util/error.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'types.freezed.dart';

// The type `AddressIndex` is not used by any `pub` functions, thus it is ignored.
// The type `AddressInfo` is not used by any `pub` functions, thus it is ignored.
// The type `Balance` is not used by any `pub` functions, thus it is ignored.
// The type `BlockTime` is not used by any `pub` functions, thus it is ignored.
// The type `ChangeSpendPolicy` is not used by any `pub` functions, thus it is ignored.
// The type `KeychainKind` is not used by any `pub` functions, thus it is ignored.
// The type `PsbtSigHashType` is not used by any `pub` functions, thus it is ignored.
// The type `RbfValue` is not used by any `pub` functions, thus it is ignored.
// The type `ScriptAmount` is not used by any `pub` functions, thus it is ignored.
// The type `TransactionDetails` is not used by any `pub` functions, thus it is ignored.
// The type `WordCount` is not used by any `pub` functions, thus it is ignored.

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<bdk :: bitcoin :: Address>>
@sealed
class BdkBitcoinAddress extends RustOpaque {
  BdkBitcoinAddress.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  BdkBitcoinAddress.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        BdkCore.instance.api.rust_arc_increment_strong_count_BdkBitcoinAddress,
    rustArcDecrementStrongCount:
        BdkCore.instance.api.rust_arc_decrement_strong_count_BdkBitcoinAddress,
    rustArcDecrementStrongCountPtr: BdkCore
        .instance.api.rust_arc_decrement_strong_count_BdkBitcoinAddressPtr,
  );
}

class AddressBase {
  final BdkBitcoinAddress field0;

  const AddressBase({
    required this.field0,
  });

  Future<String> asString({dynamic hint}) =>
      BdkCore.instance.api.addressBaseAsString(
        that: this,
      );

  static Future<AddressBase> fromScript(
          {required ScriptBufBase script,
          required Network network,
          dynamic hint}) =>
      BdkCore.instance.api
          .addressBaseFromScript(script: script, network: network, hint: hint);

  static Future<AddressBase> fromString(
          {required String address, required Network network, dynamic hint}) =>
      BdkCore.instance.api.addressBaseFromString(
          address: address, network: network, hint: hint);

  Future<bool> isValidForNetwork({required Network network, dynamic hint}) =>
      BdkCore.instance.api.addressBaseIsValidForNetwork(
        that: this,
        network: network,
      );

  ///The network on which this address is usable.
  Future<Network> network({dynamic hint}) =>
      BdkCore.instance.api.addressBaseNetwork(
        that: this,
      );

  Future<Payload> payload({dynamic hint}) =>
      BdkCore.instance.api.addressBasePayload(
        that: this,
      );

  Future<ScriptBufBase> scriptPubkey({dynamic hint}) =>
      BdkCore.instance.api.addressBaseScriptPubkey(
        that: this,
      );

  ///Creates a URI string bitcoin:address optimized to be encoded in QR codes.
  Future<String> toQrUri({dynamic hint}) =>
      BdkCore.instance.api.addressBaseToQrUri(
        that: this,
      );

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AddressBase &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

///The cryptocurrency to act on
enum Network {
  ///Bitcoin’s testnet
  testnet,

  ///Bitcoin’s regtest
  regtest,

  ///Classic Bitcoin
  bitcoin,

  ///Bitcoin’s signet
  signet,
}

/// A reference to a transaction output.
class OutPoint {
  /// The referenced transaction's txid.
  final String txid;

  /// The index of the referenced output in its transaction's vout.
  final int vout;

  const OutPoint({
    required this.txid,
    required this.vout,
  });

  @override
  int get hashCode => txid.hashCode ^ vout.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OutPoint &&
          runtimeType == other.runtimeType &&
          txid == other.txid &&
          vout == other.vout;
}

@freezed
sealed class Payload with _$Payload {
  /// P2PKH address.
  const factory Payload.pubkeyHash({
    required String pubkeyHash,
  }) = Payload_PubkeyHash;

  /// P2SH address.
  const factory Payload.scriptHash({
    required String scriptHash,
  }) = Payload_ScriptHash;

  /// Segwit address.
  const factory Payload.witnessProgram({
    /// The witness program version.
    required WitnessVersion version,

    /// The witness program.
    required Uint8List program,
  }) = Payload_WitnessProgram;
}

class ScriptBufBase {
  final Uint8List bytes;

  const ScriptBufBase({
    required this.bytes,
  });

  ///Creates a new empty script.
  static Future<ScriptBufBase> empty({dynamic hint}) =>
      BdkCore.instance.api.scriptBufBaseEmpty(hint: hint);

  static Future<ScriptBufBase> fromHex({required String s, dynamic hint}) =>
      BdkCore.instance.api.scriptBufBaseFromHex(s: s, hint: hint);

  ///Creates a new empty script with pre-allocated capacity.
  static Future<ScriptBufBase> withCapacity(
          {required int capacity, dynamic hint}) =>
      BdkCore.instance.api
          .scriptBufBaseWithCapacity(capacity: capacity, hint: hint);

  @override
  int get hashCode => bytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ScriptBufBase &&
          runtimeType == other.runtimeType &&
          bytes == other.bytes;
}

class TransactionBase {
  final String inner;

  const TransactionBase({
    required this.inner,
  });

  Future<List<TxIn>> input({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseInput(
        that: this,
      );

  Future<bool> isCoinBase({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseIsCoinBase(
        that: this,
      );

  Future<bool> isExplicitlyRbf({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseIsExplicitlyRbf(
        that: this,
      );

  Future<bool> isLockTimeEnabled({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseIsLockTimeEnabled(
        that: this,
      );

  Future<int> lockTime({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseLockTime(
        that: this,
      );

  static Future<TransactionBase> newTransactionBase(
          {required List<int> transactionBytes, dynamic hint}) =>
      BdkCore.instance.api
          .transactionBaseNew(transactionBytes: transactionBytes, hint: hint);

  Future<List<TxOut>> output({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseOutput(
        that: this,
      );

  Future<Uint8List> serialize({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseSerialize(
        that: this,
      );

  Future<int> size({dynamic hint}) => BdkCore.instance.api.transactionBaseSize(
        that: this,
      );

  Future<String> txid({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseTxid(
        that: this,
      );

  Future<int> version({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseVersion(
        that: this,
      );

  Future<int> vsize({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseVsize(
        that: this,
      );

  Future<int> weight({dynamic hint}) =>
      BdkCore.instance.api.transactionBaseWeight(
        that: this,
      );

  @override
  int get hashCode => inner.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TransactionBase &&
          runtimeType == other.runtimeType &&
          inner == other.inner;
}

class TxIn {
  final OutPoint previousOutput;
  final ScriptBufBase scriptSig;
  final int sequence;
  final List<Uint8List> witness;

  const TxIn({
    required this.previousOutput,
    required this.scriptSig,
    required this.sequence,
    required this.witness,
  });

  @override
  int get hashCode =>
      previousOutput.hashCode ^
      scriptSig.hashCode ^
      sequence.hashCode ^
      witness.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxIn &&
          runtimeType == other.runtimeType &&
          previousOutput == other.previousOutput &&
          scriptSig == other.scriptSig &&
          sequence == other.sequence &&
          witness == other.witness;
}

///A transaction output, which defines new coins to be created from old ones.
class TxOut {
  /// The value of the output, in satoshis.
  final int value;

  /// The address of the output.
  final ScriptBufBase scriptPubkey;

  const TxOut({
    required this.value,
    required this.scriptPubkey,
  });

  @override
  int get hashCode => value.hashCode ^ scriptPubkey.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TxOut &&
          runtimeType == other.runtimeType &&
          value == other.value &&
          scriptPubkey == other.scriptPubkey;
}

class U8Array4 extends NonGrowableListView<int> {
  static const arraySize = 4;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array4(this._inner)
      : assert(_inner.length == arraySize),
        super(_inner);

  U8Array4.init() : this(Uint8List(arraySize));
}

enum Variant {
  bech32,
  bech32M,
}

enum WitnessVersion {
  /// Initial version of witness program. Used for P2WPKH and P2WPK outputs
  v0,

  /// Version of witness program used for Taproot P2TR outputs.
  v1,

  /// Future (unsupported) version of witness program.
  v2,

  /// Future (unsupported) version of witness program.
  v3,

  /// Future (unsupported) version of witness program.
  v4,

  /// Future (unsupported) version of witness program.
  v5,

  /// Future (unsupported) version of witness program.
  v6,

  /// Future (unsupported) version of witness program.
  v7,

  /// Future (unsupported) version of witness program.
  v8,

  /// Future (unsupported) version of witness program.
  v9,

  /// Future (unsupported) version of witness program.
  v10,

  /// Future (unsupported) version of witness program.
  v11,

  /// Future (unsupported) version of witness program.
  v12,

  /// Future (unsupported) version of witness program.
  v13,

  /// Future (unsupported) version of witness program.
  v14,

  /// Future (unsupported) version of witness program.
  v15,

  /// Future (unsupported) version of witness program.
  v16,
}
