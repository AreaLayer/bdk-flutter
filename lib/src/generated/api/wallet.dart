// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.25.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'blockchain.dart';
import 'descriptor.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'psbt.dart';
import 'types.dart';

Future<(PsbtBase, TransactionDetails)> finishBumpFeeTxBuilder(
        {required String txid,
        required double feeRate,
        AddressBase? allowShrinking,
        required WalletBase wallet,
        required bool enableRbf,
        int? nSequence,
        dynamic hint}) =>
    BdkCore.instance.api.finishBumpFeeTxBuilder(
        txid: txid,
        feeRate: feeRate,
        allowShrinking: allowShrinking,
        wallet: wallet,
        enableRbf: enableRbf,
        nSequence: nSequence,
        hint: hint);

Future<(PsbtBase, TransactionDetails)> txBuilderFinish(
        {required WalletBase wallet,
        required List<ScriptAmount> recipients,
        required List<OutPoint> utxos,
        (OutPoint, Input, int)? foreignUtxo,
        required List<OutPoint> unSpendable,
        required ChangeSpendPolicy changePolicy,
        required bool manuallySelectedOnly,
        double? feeRate,
        int? feeAbsolute,
        required bool drainWallet,
        ScriptBufBase? drainTo,
        RbfValue? rbf,
        required List<int> data,
        dynamic hint}) =>
    BdkCore.instance.api.txBuilderFinish(
        wallet: wallet,
        recipients: recipients,
        utxos: utxos,
        foreignUtxo: foreignUtxo,
        unSpendable: unSpendable,
        changePolicy: changePolicy,
        manuallySelectedOnly: manuallySelectedOnly,
        feeRate: feeRate,
        feeAbsolute: feeAbsolute,
        drainWallet: drainWallet,
        drainTo: drainTo,
        rbf: rbf,
        data: data,
        hint: hint);

// Rust type: RustOpaqueNom<Mutex < bdk :: Wallet < AnyDatabase > >>
@sealed
class MutexBdkWalletAnyDatabase extends RustOpaque {
  MutexBdkWalletAnyDatabase.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MutexBdkWalletAnyDatabase.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: BdkCore
        .instance.api.rust_arc_increment_strong_count_MutexBdkWalletAnyDatabase,
    rustArcDecrementStrongCount: BdkCore
        .instance.api.rust_arc_decrement_strong_count_MutexBdkWalletAnyDatabase,
    rustArcDecrementStrongCountPtr: BdkCore.instance.api
        .rust_arc_decrement_strong_count_MutexBdkWalletAnyDatabasePtr,
  );
}

/// A Bitcoin wallet.
/// The Wallet acts as a way of coherently interfacing with output descriptors and related transactions. Its main components are:
///     1. Output descriptors from which it can derive addresses.
///     2. A Database where it tracks transactions and utxos related to the descriptors.
///     3. Signers that can contribute signatures to addresses instantiated from the descriptors.
class WalletBase {
  final MutexBdkWalletAnyDatabase ptr;

  const WalletBase({
    required this.ptr,
  });

  /// Return a derived address using the external descriptor, see AddressIndex for available address index selection
  /// strategies. If none of the keys in the descriptor are derivable (i.e. the descriptor does not end with a * character)
  /// then the same address will always be returned for any AddressIndex.
  Future<AddressInfo> getAddress(
          {required AddressIndex addressIndex, dynamic hint}) =>
      BdkCore.instance.api.walletBaseGetAddress(
        that: this,
        addressIndex: addressIndex,
      );

  /// Return the balance, meaning the sum of this wallet’s unspent outputs’ values. Note that this method only operates
  /// on the internal database, which first needs to be Wallet.sync manually.
  Future<Balance> getBalance({dynamic hint}) =>
      BdkCore.instance.api.walletBaseGetBalance(
        that: this,
      );

  ///Returns the descriptor used to create addresses for a particular keychain.
  Future<DescriptorBase> getDescriptorForKeychain(
          {required KeychainKind keychain, dynamic hint}) =>
      BdkCore.instance.api.walletBaseGetDescriptorForKeychain(
        that: this,
        keychain: keychain,
      );

  /// Return a derived address using the internal (change) descriptor.
  ///
  /// If the wallet doesn't have an internal descriptor it will use the external descriptor.
  ///
  /// see [AddressIndex] for available address index selection strategies. If none of the keys
  /// in the descriptor are derivable (i.e. does not end with /*) then the same address will always
  /// be returned for any [AddressIndex].
  Future<AddressInfo> getInternalAddress(
          {required AddressIndex addressIndex, dynamic hint}) =>
      BdkCore.instance.api.walletBaseGetInternalAddress(
        that: this,
        addressIndex: addressIndex,
      );

  ///get the corresponding PSBT Input for a LocalUtxo
  Future<Input> getPsbtInput(
          {required LocalUtxo utxo,
          required bool onlyWitnessUtxo,
          PsbtSigHashType? sighashType,
          dynamic hint}) =>
      BdkCore.instance.api.walletBaseGetPsbtInput(
        that: this,
        utxo: utxo,
        onlyWitnessUtxo: onlyWitnessUtxo,
        sighashType: sighashType,
      );

  /// Return whether or not a script is part of this wallet (either internal or external).
  Future<bool> isMine({required ScriptBufBase script, dynamic hint}) =>
      BdkCore.instance.api.walletBaseIsMine(
        that: this,
        script: script,
      );

  /// Return the list of transactions made and received by the wallet. Note that this method only operate on the internal database, which first needs to be [Wallet.sync] manually.
  Future<List<TransactionDetails>> listTransactions(
          {required bool includeRaw, dynamic hint}) =>
      BdkCore.instance.api.walletBaseListTransactions(
        that: this,
        includeRaw: includeRaw,
      );

  /// Return the list of unspent outputs of this wallet. Note that this method only operates on the internal database,
  /// which first needs to be Wallet.sync manually.
  Future<List<LocalUtxo>> listUnspent({dynamic hint}) =>
      BdkCore.instance.api.walletBaseListUnspent(
        that: this,
      );

  /// Get the Bitcoin network the wallet is using.
  Future<Network> network({dynamic hint}) =>
      BdkCore.instance.api.walletBaseNetwork(
        that: this,
      );

  static Future<WalletBase> newWalletBase(
          {required DescriptorBase descriptor,
          DescriptorBase? changeDescriptor,
          required Network network,
          required DatabaseConfig databaseConfig,
          dynamic hint}) =>
      BdkCore.instance.api.walletBaseNew(
          descriptor: descriptor,
          changeDescriptor: changeDescriptor,
          network: network,
          databaseConfig: databaseConfig,
          hint: hint);

  /// Sign a transaction with all the wallet's signers. This function returns an encapsulated bool that
  /// has the value true if the PSBT was finalized, or false otherwise.
  ///
  /// The [SignOptions] can be used to tweak the behavior of the software signers, and the way
  /// the transaction is finalized at the end. Note that it can't be guaranteed that *every*
  /// signers will follow the options, but the "software signers" (WIF keys and `xprv`) defined
  /// in this library will.
  Future<bool> sign(
          {required PsbtBase psbt, SignOptions? signOptions, dynamic hint}) =>
      BdkCore.instance.api.walletBaseSign(
        that: this,
        psbt: psbt,
        signOptions: signOptions,
      );

  /// Sync the internal database with the blockchain.
  Future<void> sync({required BlockchainBase blockchain, dynamic hint}) =>
      BdkCore.instance.api.walletBaseSync(
        that: this,
        blockchain: blockchain,
      );

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WalletBase &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}
