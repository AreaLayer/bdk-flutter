// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.28.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'blockchain.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<DerivationPathBase>>
@sealed
class DerivationPathBase extends RustOpaque {
  DerivationPathBase.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  DerivationPathBase.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        BdkCore.instance.api.rust_arc_increment_strong_count_DerivationPathBase,
    rustArcDecrementStrongCount:
        BdkCore.instance.api.rust_arc_decrement_strong_count_DerivationPathBase,
    rustArcDecrementStrongCountPtr: BdkCore
        .instance.api.rust_arc_decrement_strong_count_DerivationPathBasePtr,
  );

  static Future<DerivationPathBase> fromString(
          {required String path, dynamic hint}) =>
      BdkCore.instance.api.derivationPathBaseFromString(path: path, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<DescriptorPublicKeyBase>>
@sealed
class DescriptorPublicKeyBase extends RustOpaque {
  DescriptorPublicKeyBase.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  DescriptorPublicKeyBase.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: BdkCore
        .instance.api.rust_arc_increment_strong_count_DescriptorPublicKeyBase,
    rustArcDecrementStrongCount: BdkCore
        .instance.api.rust_arc_decrement_strong_count_DescriptorPublicKeyBase,
    rustArcDecrementStrongCountPtr: BdkCore.instance.api
        .rust_arc_decrement_strong_count_DescriptorPublicKeyBasePtr,
  );

  Future<String> asString({dynamic hint}) =>
      BdkCore.instance.api.descriptorPublicKeyBaseAsString(
        that: this,
      );

  static Future<DescriptorPublicKeyBase> derive(
          {required DescriptorPublicKeyBase ptr,
          required DerivationPathBase path,
          dynamic hint}) =>
      BdkCore.instance.api
          .descriptorPublicKeyBaseDerive(ptr: ptr, path: path, hint: hint);

  static Future<DescriptorPublicKeyBase> extend(
          {required DescriptorPublicKeyBase ptr,
          required DerivationPathBase path,
          dynamic hint}) =>
      BdkCore.instance.api
          .descriptorPublicKeyBaseExtend(ptr: ptr, path: path, hint: hint);

  static Future<DescriptorPublicKeyBase> fromString(
          {required String publicKey, dynamic hint}) =>
      BdkCore.instance.api
          .descriptorPublicKeyBaseFromString(publicKey: publicKey, hint: hint);
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<DescriptorSecretKeyBase>>
@sealed
class DescriptorSecretKeyBase extends RustOpaque {
  DescriptorSecretKeyBase.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  DescriptorSecretKeyBase.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: BdkCore
        .instance.api.rust_arc_increment_strong_count_DescriptorSecretKeyBase,
    rustArcDecrementStrongCount: BdkCore
        .instance.api.rust_arc_decrement_strong_count_DescriptorSecretKeyBase,
    rustArcDecrementStrongCountPtr: BdkCore.instance.api
        .rust_arc_decrement_strong_count_DescriptorSecretKeyBasePtr,
  );

  static Future<DescriptorPublicKeyBase> asPublic(
          {required DescriptorSecretKeyBase ptr, dynamic hint}) =>
      BdkCore.instance.api
          .descriptorSecretKeyBaseAsPublic(ptr: ptr, hint: hint);

  Future<String> asString({dynamic hint}) =>
      BdkCore.instance.api.descriptorSecretKeyBaseAsString(
        that: this,
      );

  static Future<DescriptorSecretKeyBase> create(
          {required Network network,
          required MnemonicBase mnemonic,
          String? password,
          dynamic hint}) =>
      BdkCore.instance.api.descriptorSecretKeyBaseCreate(
          network: network, mnemonic: mnemonic, password: password, hint: hint);

  static Future<DescriptorSecretKeyBase> derive(
          {required DescriptorSecretKeyBase ptr,
          required DerivationPathBase path,
          dynamic hint}) =>
      BdkCore.instance.api
          .descriptorSecretKeyBaseDerive(ptr: ptr, path: path, hint: hint);

  static Future<DescriptorSecretKeyBase> extend(
          {required DescriptorSecretKeyBase ptr,
          required DerivationPathBase path,
          dynamic hint}) =>
      BdkCore.instance.api
          .descriptorSecretKeyBaseExtend(ptr: ptr, path: path, hint: hint);

  static Future<DescriptorSecretKeyBase> fromString(
          {required String secretKey, dynamic hint}) =>
      BdkCore.instance.api
          .descriptorSecretKeyBaseFromString(secretKey: secretKey, hint: hint);

  /// Get the private key as bytes.
  Future<Uint8List> secretBytes({dynamic hint}) =>
      BdkCore.instance.api.descriptorSecretKeyBaseSecretBytes(
        that: this,
      );
}

// Rust type: RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<MnemonicBase>>
@sealed
class MnemonicBase extends RustOpaque {
  MnemonicBase.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  MnemonicBase.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        BdkCore.instance.api.rust_arc_increment_strong_count_MnemonicBase,
    rustArcDecrementStrongCount:
        BdkCore.instance.api.rust_arc_decrement_strong_count_MnemonicBase,
    rustArcDecrementStrongCountPtr:
        BdkCore.instance.api.rust_arc_decrement_strong_count_MnemonicBasePtr,
  );

  /// Returns Mnemonic as string
  Future<String> asString({dynamic hint}) =>
      BdkCore.instance.api.mnemonicBaseAsString(
        that: this,
      );

  /// Create a new Mnemonic in the specified language from the given entropy.
  /// Entropy must be a multiple of 32 bits (4 bytes) and 128-256 bits in length.
  static Future<MnemonicBase> fromEntropy(
          {required List<int> entropy, dynamic hint}) =>
      BdkCore.instance.api
          .mnemonicBaseFromEntropy(entropy: entropy, hint: hint);

  /// Parse a Mnemonic with given string
  static Future<MnemonicBase> fromString(
          {required String mnemonic, dynamic hint}) =>
      BdkCore.instance.api
          .mnemonicBaseFromString(mnemonic: mnemonic, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Generates Mnemonic with a random entropy
  static Future<MnemonicBase> newInstance(
          {required WordCount wordCount, dynamic hint}) =>
      BdkCore.instance.api.mnemonicBaseNew(wordCount: wordCount, hint: hint);
}
