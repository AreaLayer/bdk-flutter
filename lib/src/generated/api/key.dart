// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.28.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'blockchain.dart';
import 'descriptor.dart';
import 'error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'types.dart';

// Rust type: RustOpaqueNom<bitcoin :: bip32 :: DerivationPath>
@sealed
class BitcoinBip32DerivationPath extends RustOpaque {
  BitcoinBip32DerivationPath.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  BitcoinBip32DerivationPath.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: BdkCore.instance.api
        .rust_arc_increment_strong_count_BitcoinBip32DerivationPath,
    rustArcDecrementStrongCount: BdkCore.instance.api
        .rust_arc_decrement_strong_count_BitcoinBip32DerivationPath,
    rustArcDecrementStrongCountPtr: BdkCore.instance.api
        .rust_arc_decrement_strong_count_BitcoinBip32DerivationPathPtr,
  );
}

// Rust type: RustOpaqueNom<keys :: bip39 :: Mnemonic>
@sealed
class KeysBip39Mnemonic extends RustOpaque {
  KeysBip39Mnemonic.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  KeysBip39Mnemonic.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        BdkCore.instance.api.rust_arc_increment_strong_count_KeysBip39Mnemonic,
    rustArcDecrementStrongCount:
        BdkCore.instance.api.rust_arc_decrement_strong_count_KeysBip39Mnemonic,
    rustArcDecrementStrongCountPtr: BdkCore
        .instance.api.rust_arc_decrement_strong_count_KeysBip39MnemonicPtr,
  );
}

class DerivationPathBase {
  final BitcoinBip32DerivationPath ptr;

  const DerivationPathBase({
    required this.ptr,
  });

  static Future<DerivationPathBase> fromString(
          {required String path, dynamic hint}) =>
      BdkCore.instance.api.derivationPathBaseFromString(path: path, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DerivationPathBase &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}

class DescriptorPublicKeyBase {
  final KeysDescriptorPublicKey ptr;

  const DescriptorPublicKeyBase({
    required this.ptr,
  });

  Future<String> asString({dynamic hint}) =>
      BdkCore.instance.api.descriptorPublicKeyBaseAsString(
        that: this,
      );

  static Future<DescriptorPublicKeyBase> derive(
          {required DescriptorPublicKeyBase ptr,
          required DerivationPathBase path,
          dynamic hint}) =>
      BdkCore.instance.api
          .descriptorPublicKeyBaseDerive(ptr: ptr, path: path, hint: hint);

  static Future<DescriptorPublicKeyBase> extend(
          {required DescriptorPublicKeyBase ptr,
          required DerivationPathBase path,
          dynamic hint}) =>
      BdkCore.instance.api
          .descriptorPublicKeyBaseExtend(ptr: ptr, path: path, hint: hint);

  static Future<DescriptorPublicKeyBase> fromString(
          {required String publicKey, dynamic hint}) =>
      BdkCore.instance.api
          .descriptorPublicKeyBaseFromString(publicKey: publicKey, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DescriptorPublicKeyBase &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}

class DescriptorSecretKeyBase {
  final KeysDescriptorSecretKey ptr;

  const DescriptorSecretKeyBase({
    required this.ptr,
  });

  static Future<DescriptorPublicKeyBase> asPublic(
          {required DescriptorSecretKeyBase ptr, dynamic hint}) =>
      BdkCore.instance.api
          .descriptorSecretKeyBaseAsPublic(ptr: ptr, hint: hint);

  Future<String> asString({dynamic hint}) =>
      BdkCore.instance.api.descriptorSecretKeyBaseAsString(
        that: this,
      );

  static Future<DescriptorSecretKeyBase> create(
          {required Network network,
          required MnemonicBase mnemonic,
          String? password,
          dynamic hint}) =>
      BdkCore.instance.api.descriptorSecretKeyBaseCreate(
          network: network, mnemonic: mnemonic, password: password, hint: hint);

  static Future<DescriptorSecretKeyBase> derive(
          {required DescriptorSecretKeyBase ptr,
          required DerivationPathBase path,
          dynamic hint}) =>
      BdkCore.instance.api
          .descriptorSecretKeyBaseDerive(ptr: ptr, path: path, hint: hint);

  static Future<DescriptorSecretKeyBase> extend(
          {required DescriptorSecretKeyBase ptr,
          required DerivationPathBase path,
          dynamic hint}) =>
      BdkCore.instance.api
          .descriptorSecretKeyBaseExtend(ptr: ptr, path: path, hint: hint);

  static Future<DescriptorSecretKeyBase> fromString(
          {required String secretKey, dynamic hint}) =>
      BdkCore.instance.api
          .descriptorSecretKeyBaseFromString(secretKey: secretKey, hint: hint);

  /// Get the private key as bytes.
  Future<Uint8List> secretBytes({dynamic hint}) =>
      BdkCore.instance.api.descriptorSecretKeyBaseSecretBytes(
        that: this,
      );

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DescriptorSecretKeyBase &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}

class MnemonicBase {
  final KeysBip39Mnemonic ptr;

  const MnemonicBase({
    required this.ptr,
  });

  /// Returns Mnemonic as string
  Future<String> asString({dynamic hint}) =>
      BdkCore.instance.api.mnemonicBaseAsString(
        that: this,
      );

  /// Create a new Mnemonic in the specified language from the given entropy.
  /// Entropy must be a multiple of 32 bits (4 bytes) and 128-256 bits in length.
  static Future<MnemonicBase> fromEntropy(
          {required List<int> entropy, dynamic hint}) =>
      BdkCore.instance.api
          .mnemonicBaseFromEntropy(entropy: entropy, hint: hint);

  /// Parse a Mnemonic with given string
  static Future<MnemonicBase> fromString(
          {required String mnemonic, dynamic hint}) =>
      BdkCore.instance.api
          .mnemonicBaseFromString(mnemonic: mnemonic, hint: hint);

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Generates Mnemonic with a random entropy
  static Future<MnemonicBase> newInstance(
          {required WordCount wordCount, dynamic hint}) =>
      BdkCore.instance.api.mnemonicBaseNew(wordCount: wordCount, hint: hint);

  @override
  int get hashCode => ptr.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MnemonicBase &&
          runtimeType == other.runtimeType &&
          ptr == other.ptr;
}
