// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'types.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AddressIndex {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AddressIndexCopyWith<$Res> {
  factory $AddressIndexCopyWith(
          AddressIndex value, $Res Function(AddressIndex) then) =
      _$AddressIndexCopyWithImpl<$Res, AddressIndex>;
}

/// @nodoc
class _$AddressIndexCopyWithImpl<$Res, $Val extends AddressIndex>
    implements $AddressIndexCopyWith<$Res> {
  _$AddressIndexCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AddressIndex_IncreaseImplCopyWith<$Res> {
  factory _$$AddressIndex_IncreaseImplCopyWith(
          _$AddressIndex_IncreaseImpl value,
          $Res Function(_$AddressIndex_IncreaseImpl) then) =
      __$$AddressIndex_IncreaseImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressIndex_IncreaseImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_IncreaseImpl>
    implements _$$AddressIndex_IncreaseImplCopyWith<$Res> {
  __$$AddressIndex_IncreaseImplCopyWithImpl(_$AddressIndex_IncreaseImpl _value,
      $Res Function(_$AddressIndex_IncreaseImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressIndex_IncreaseImpl extends AddressIndex_Increase {
  const _$AddressIndex_IncreaseImpl() : super._();

  @override
  String toString() {
    return 'AddressIndex.increase()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_IncreaseImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return increase();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return increase?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (increase != null) {
      return increase();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return increase(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return increase?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (increase != null) {
      return increase(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_Increase extends AddressIndex {
  const factory AddressIndex_Increase() = _$AddressIndex_IncreaseImpl;
  const AddressIndex_Increase._() : super._();
}

/// @nodoc
abstract class _$$AddressIndex_LastUnusedImplCopyWith<$Res> {
  factory _$$AddressIndex_LastUnusedImplCopyWith(
          _$AddressIndex_LastUnusedImpl value,
          $Res Function(_$AddressIndex_LastUnusedImpl) then) =
      __$$AddressIndex_LastUnusedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AddressIndex_LastUnusedImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_LastUnusedImpl>
    implements _$$AddressIndex_LastUnusedImplCopyWith<$Res> {
  __$$AddressIndex_LastUnusedImplCopyWithImpl(
      _$AddressIndex_LastUnusedImpl _value,
      $Res Function(_$AddressIndex_LastUnusedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AddressIndex_LastUnusedImpl extends AddressIndex_LastUnused {
  const _$AddressIndex_LastUnusedImpl() : super._();

  @override
  String toString() {
    return 'AddressIndex.lastUnused()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_LastUnusedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return lastUnused();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return lastUnused?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (lastUnused != null) {
      return lastUnused();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return lastUnused(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return lastUnused?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (lastUnused != null) {
      return lastUnused(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_LastUnused extends AddressIndex {
  const factory AddressIndex_LastUnused() = _$AddressIndex_LastUnusedImpl;
  const AddressIndex_LastUnused._() : super._();
}

/// @nodoc
abstract class _$$AddressIndex_PeekImplCopyWith<$Res> {
  factory _$$AddressIndex_PeekImplCopyWith(_$AddressIndex_PeekImpl value,
          $Res Function(_$AddressIndex_PeekImpl) then) =
      __$$AddressIndex_PeekImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$AddressIndex_PeekImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_PeekImpl>
    implements _$$AddressIndex_PeekImplCopyWith<$Res> {
  __$$AddressIndex_PeekImplCopyWithImpl(_$AddressIndex_PeekImpl _value,
      $Res Function(_$AddressIndex_PeekImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$AddressIndex_PeekImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$AddressIndex_PeekImpl extends AddressIndex_Peek {
  const _$AddressIndex_PeekImpl({required this.index}) : super._();

  @override
  final int index;

  @override
  String toString() {
    return 'AddressIndex.peek(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_PeekImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressIndex_PeekImplCopyWith<_$AddressIndex_PeekImpl> get copyWith =>
      __$$AddressIndex_PeekImplCopyWithImpl<_$AddressIndex_PeekImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return peek(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return peek?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (peek != null) {
      return peek(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return peek(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return peek?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (peek != null) {
      return peek(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_Peek extends AddressIndex {
  const factory AddressIndex_Peek({required final int index}) =
      _$AddressIndex_PeekImpl;
  const AddressIndex_Peek._() : super._();

  int get index;
  @JsonKey(ignore: true)
  _$$AddressIndex_PeekImplCopyWith<_$AddressIndex_PeekImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AddressIndex_ResetImplCopyWith<$Res> {
  factory _$$AddressIndex_ResetImplCopyWith(_$AddressIndex_ResetImpl value,
          $Res Function(_$AddressIndex_ResetImpl) then) =
      __$$AddressIndex_ResetImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$AddressIndex_ResetImplCopyWithImpl<$Res>
    extends _$AddressIndexCopyWithImpl<$Res, _$AddressIndex_ResetImpl>
    implements _$$AddressIndex_ResetImplCopyWith<$Res> {
  __$$AddressIndex_ResetImplCopyWithImpl(_$AddressIndex_ResetImpl _value,
      $Res Function(_$AddressIndex_ResetImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$AddressIndex_ResetImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$AddressIndex_ResetImpl extends AddressIndex_Reset {
  const _$AddressIndex_ResetImpl({required this.index}) : super._();

  @override
  final int index;

  @override
  String toString() {
    return 'AddressIndex.reset(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AddressIndex_ResetImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AddressIndex_ResetImplCopyWith<_$AddressIndex_ResetImpl> get copyWith =>
      __$$AddressIndex_ResetImplCopyWithImpl<_$AddressIndex_ResetImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() increase,
    required TResult Function() lastUnused,
    required TResult Function(int index) peek,
    required TResult Function(int index) reset,
  }) {
    return reset(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? increase,
    TResult? Function()? lastUnused,
    TResult? Function(int index)? peek,
    TResult? Function(int index)? reset,
  }) {
    return reset?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? increase,
    TResult Function()? lastUnused,
    TResult Function(int index)? peek,
    TResult Function(int index)? reset,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AddressIndex_Increase value) increase,
    required TResult Function(AddressIndex_LastUnused value) lastUnused,
    required TResult Function(AddressIndex_Peek value) peek,
    required TResult Function(AddressIndex_Reset value) reset,
  }) {
    return reset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AddressIndex_Increase value)? increase,
    TResult? Function(AddressIndex_LastUnused value)? lastUnused,
    TResult? Function(AddressIndex_Peek value)? peek,
    TResult? Function(AddressIndex_Reset value)? reset,
  }) {
    return reset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AddressIndex_Increase value)? increase,
    TResult Function(AddressIndex_LastUnused value)? lastUnused,
    TResult Function(AddressIndex_Peek value)? peek,
    TResult Function(AddressIndex_Reset value)? reset,
    required TResult orElse(),
  }) {
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class AddressIndex_Reset extends AddressIndex {
  const factory AddressIndex_Reset({required final int index}) =
      _$AddressIndex_ResetImpl;
  const AddressIndex_Reset._() : super._();

  int get index;
  @JsonKey(ignore: true)
  _$$AddressIndex_ResetImplCopyWith<_$AddressIndex_ResetImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DatabaseConfig {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DatabaseConfigCopyWith<$Res> {
  factory $DatabaseConfigCopyWith(
          DatabaseConfig value, $Res Function(DatabaseConfig) then) =
      _$DatabaseConfigCopyWithImpl<$Res, DatabaseConfig>;
}

/// @nodoc
class _$DatabaseConfigCopyWithImpl<$Res, $Val extends DatabaseConfig>
    implements $DatabaseConfigCopyWith<$Res> {
  _$DatabaseConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$DatabaseConfig_MemoryImplCopyWith<$Res> {
  factory _$$DatabaseConfig_MemoryImplCopyWith(
          _$DatabaseConfig_MemoryImpl value,
          $Res Function(_$DatabaseConfig_MemoryImpl) then) =
      __$$DatabaseConfig_MemoryImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$DatabaseConfig_MemoryImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_MemoryImpl>
    implements _$$DatabaseConfig_MemoryImplCopyWith<$Res> {
  __$$DatabaseConfig_MemoryImplCopyWithImpl(_$DatabaseConfig_MemoryImpl _value,
      $Res Function(_$DatabaseConfig_MemoryImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$DatabaseConfig_MemoryImpl extends DatabaseConfig_Memory {
  const _$DatabaseConfig_MemoryImpl() : super._();

  @override
  String toString() {
    return 'DatabaseConfig.memory()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_MemoryImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return memory();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return memory?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (memory != null) {
      return memory();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return memory(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return memory?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (memory != null) {
      return memory(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Memory extends DatabaseConfig {
  const factory DatabaseConfig_Memory() = _$DatabaseConfig_MemoryImpl;
  const DatabaseConfig_Memory._() : super._();
}

/// @nodoc
abstract class _$$DatabaseConfig_SqliteImplCopyWith<$Res> {
  factory _$$DatabaseConfig_SqliteImplCopyWith(
          _$DatabaseConfig_SqliteImpl value,
          $Res Function(_$DatabaseConfig_SqliteImpl) then) =
      __$$DatabaseConfig_SqliteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SqliteDbConfiguration config});
}

/// @nodoc
class __$$DatabaseConfig_SqliteImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_SqliteImpl>
    implements _$$DatabaseConfig_SqliteImplCopyWith<$Res> {
  __$$DatabaseConfig_SqliteImplCopyWithImpl(_$DatabaseConfig_SqliteImpl _value,
      $Res Function(_$DatabaseConfig_SqliteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$DatabaseConfig_SqliteImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as SqliteDbConfiguration,
    ));
  }
}

/// @nodoc

class _$DatabaseConfig_SqliteImpl extends DatabaseConfig_Sqlite {
  const _$DatabaseConfig_SqliteImpl({required this.config}) : super._();

  @override
  final SqliteDbConfiguration config;

  @override
  String toString() {
    return 'DatabaseConfig.sqlite(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_SqliteImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DatabaseConfig_SqliteImplCopyWith<_$DatabaseConfig_SqliteImpl>
      get copyWith => __$$DatabaseConfig_SqliteImplCopyWithImpl<
          _$DatabaseConfig_SqliteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return sqlite(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return sqlite?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (sqlite != null) {
      return sqlite(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return sqlite(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return sqlite?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (sqlite != null) {
      return sqlite(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Sqlite extends DatabaseConfig {
  const factory DatabaseConfig_Sqlite(
          {required final SqliteDbConfiguration config}) =
      _$DatabaseConfig_SqliteImpl;
  const DatabaseConfig_Sqlite._() : super._();

  SqliteDbConfiguration get config;
  @JsonKey(ignore: true)
  _$$DatabaseConfig_SqliteImplCopyWith<_$DatabaseConfig_SqliteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$DatabaseConfig_SledImplCopyWith<$Res> {
  factory _$$DatabaseConfig_SledImplCopyWith(_$DatabaseConfig_SledImpl value,
          $Res Function(_$DatabaseConfig_SledImpl) then) =
      __$$DatabaseConfig_SledImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SledDbConfiguration config});
}

/// @nodoc
class __$$DatabaseConfig_SledImplCopyWithImpl<$Res>
    extends _$DatabaseConfigCopyWithImpl<$Res, _$DatabaseConfig_SledImpl>
    implements _$$DatabaseConfig_SledImplCopyWith<$Res> {
  __$$DatabaseConfig_SledImplCopyWithImpl(_$DatabaseConfig_SledImpl _value,
      $Res Function(_$DatabaseConfig_SledImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? config = null,
  }) {
    return _then(_$DatabaseConfig_SledImpl(
      config: null == config
          ? _value.config
          : config // ignore: cast_nullable_to_non_nullable
              as SledDbConfiguration,
    ));
  }
}

/// @nodoc

class _$DatabaseConfig_SledImpl extends DatabaseConfig_Sled {
  const _$DatabaseConfig_SledImpl({required this.config}) : super._();

  @override
  final SledDbConfiguration config;

  @override
  String toString() {
    return 'DatabaseConfig.sled(config: $config)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatabaseConfig_SledImpl &&
            (identical(other.config, config) || other.config == config));
  }

  @override
  int get hashCode => Object.hash(runtimeType, config);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DatabaseConfig_SledImplCopyWith<_$DatabaseConfig_SledImpl> get copyWith =>
      __$$DatabaseConfig_SledImplCopyWithImpl<_$DatabaseConfig_SledImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() memory,
    required TResult Function(SqliteDbConfiguration config) sqlite,
    required TResult Function(SledDbConfiguration config) sled,
  }) {
    return sled(config);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? memory,
    TResult? Function(SqliteDbConfiguration config)? sqlite,
    TResult? Function(SledDbConfiguration config)? sled,
  }) {
    return sled?.call(config);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? memory,
    TResult Function(SqliteDbConfiguration config)? sqlite,
    TResult Function(SledDbConfiguration config)? sled,
    required TResult orElse(),
  }) {
    if (sled != null) {
      return sled(config);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(DatabaseConfig_Memory value) memory,
    required TResult Function(DatabaseConfig_Sqlite value) sqlite,
    required TResult Function(DatabaseConfig_Sled value) sled,
  }) {
    return sled(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(DatabaseConfig_Memory value)? memory,
    TResult? Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult? Function(DatabaseConfig_Sled value)? sled,
  }) {
    return sled?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(DatabaseConfig_Memory value)? memory,
    TResult Function(DatabaseConfig_Sqlite value)? sqlite,
    TResult Function(DatabaseConfig_Sled value)? sled,
    required TResult orElse(),
  }) {
    if (sled != null) {
      return sled(this);
    }
    return orElse();
  }
}

abstract class DatabaseConfig_Sled extends DatabaseConfig {
  const factory DatabaseConfig_Sled(
      {required final SledDbConfiguration config}) = _$DatabaseConfig_SledImpl;
  const DatabaseConfig_Sled._() : super._();

  SledDbConfiguration get config;
  @JsonKey(ignore: true)
  _$$DatabaseConfig_SledImplCopyWith<_$DatabaseConfig_SledImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$LockTime {
  int get field0 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) blocks,
    required TResult Function(int field0) seconds,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? blocks,
    TResult? Function(int field0)? seconds,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? blocks,
    TResult Function(int field0)? seconds,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LockTime_Blocks value) blocks,
    required TResult Function(LockTime_Seconds value) seconds,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LockTime_Blocks value)? blocks,
    TResult? Function(LockTime_Seconds value)? seconds,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LockTime_Blocks value)? blocks,
    TResult Function(LockTime_Seconds value)? seconds,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LockTimeCopyWith<LockTime> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LockTimeCopyWith<$Res> {
  factory $LockTimeCopyWith(LockTime value, $Res Function(LockTime) then) =
      _$LockTimeCopyWithImpl<$Res, LockTime>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class _$LockTimeCopyWithImpl<$Res, $Val extends LockTime>
    implements $LockTimeCopyWith<$Res> {
  _$LockTimeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_value.copyWith(
      field0: null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LockTime_BlocksImplCopyWith<$Res>
    implements $LockTimeCopyWith<$Res> {
  factory _$$LockTime_BlocksImplCopyWith(_$LockTime_BlocksImpl value,
          $Res Function(_$LockTime_BlocksImpl) then) =
      __$$LockTime_BlocksImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LockTime_BlocksImplCopyWithImpl<$Res>
    extends _$LockTimeCopyWithImpl<$Res, _$LockTime_BlocksImpl>
    implements _$$LockTime_BlocksImplCopyWith<$Res> {
  __$$LockTime_BlocksImplCopyWithImpl(
      _$LockTime_BlocksImpl _value, $Res Function(_$LockTime_BlocksImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LockTime_BlocksImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LockTime_BlocksImpl extends LockTime_Blocks {
  const _$LockTime_BlocksImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'LockTime.blocks(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LockTime_BlocksImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LockTime_BlocksImplCopyWith<_$LockTime_BlocksImpl> get copyWith =>
      __$$LockTime_BlocksImplCopyWithImpl<_$LockTime_BlocksImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) blocks,
    required TResult Function(int field0) seconds,
  }) {
    return blocks(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? blocks,
    TResult? Function(int field0)? seconds,
  }) {
    return blocks?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? blocks,
    TResult Function(int field0)? seconds,
    required TResult orElse(),
  }) {
    if (blocks != null) {
      return blocks(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LockTime_Blocks value) blocks,
    required TResult Function(LockTime_Seconds value) seconds,
  }) {
    return blocks(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LockTime_Blocks value)? blocks,
    TResult? Function(LockTime_Seconds value)? seconds,
  }) {
    return blocks?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LockTime_Blocks value)? blocks,
    TResult Function(LockTime_Seconds value)? seconds,
    required TResult orElse(),
  }) {
    if (blocks != null) {
      return blocks(this);
    }
    return orElse();
  }
}

abstract class LockTime_Blocks extends LockTime {
  const factory LockTime_Blocks(final int field0) = _$LockTime_BlocksImpl;
  const LockTime_Blocks._() : super._();

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$LockTime_BlocksImplCopyWith<_$LockTime_BlocksImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LockTime_SecondsImplCopyWith<$Res>
    implements $LockTimeCopyWith<$Res> {
  factory _$$LockTime_SecondsImplCopyWith(_$LockTime_SecondsImpl value,
          $Res Function(_$LockTime_SecondsImpl) then) =
      __$$LockTime_SecondsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$LockTime_SecondsImplCopyWithImpl<$Res>
    extends _$LockTimeCopyWithImpl<$Res, _$LockTime_SecondsImpl>
    implements _$$LockTime_SecondsImplCopyWith<$Res> {
  __$$LockTime_SecondsImplCopyWithImpl(_$LockTime_SecondsImpl _value,
      $Res Function(_$LockTime_SecondsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$LockTime_SecondsImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$LockTime_SecondsImpl extends LockTime_Seconds {
  const _$LockTime_SecondsImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'LockTime.seconds(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LockTime_SecondsImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LockTime_SecondsImplCopyWith<_$LockTime_SecondsImpl> get copyWith =>
      __$$LockTime_SecondsImplCopyWithImpl<_$LockTime_SecondsImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int field0) blocks,
    required TResult Function(int field0) seconds,
  }) {
    return seconds(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int field0)? blocks,
    TResult? Function(int field0)? seconds,
  }) {
    return seconds?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int field0)? blocks,
    TResult Function(int field0)? seconds,
    required TResult orElse(),
  }) {
    if (seconds != null) {
      return seconds(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LockTime_Blocks value) blocks,
    required TResult Function(LockTime_Seconds value) seconds,
  }) {
    return seconds(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LockTime_Blocks value)? blocks,
    TResult? Function(LockTime_Seconds value)? seconds,
  }) {
    return seconds?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LockTime_Blocks value)? blocks,
    TResult Function(LockTime_Seconds value)? seconds,
    required TResult orElse(),
  }) {
    if (seconds != null) {
      return seconds(this);
    }
    return orElse();
  }
}

abstract class LockTime_Seconds extends LockTime {
  const factory LockTime_Seconds(final int field0) = _$LockTime_SecondsImpl;
  const LockTime_Seconds._() : super._();

  @override
  int get field0;
  @override
  @JsonKey(ignore: true)
  _$$LockTime_SecondsImplCopyWith<_$LockTime_SecondsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Payload {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String pubkeyHash) pubkeyHash,
    required TResult Function(String scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String pubkeyHash)? pubkeyHash,
    TResult? Function(String scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String pubkeyHash)? pubkeyHash,
    TResult Function(String scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PayloadCopyWith<$Res> {
  factory $PayloadCopyWith(Payload value, $Res Function(Payload) then) =
      _$PayloadCopyWithImpl<$Res, Payload>;
}

/// @nodoc
class _$PayloadCopyWithImpl<$Res, $Val extends Payload>
    implements $PayloadCopyWith<$Res> {
  _$PayloadCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Payload_PubkeyHashImplCopyWith<$Res> {
  factory _$$Payload_PubkeyHashImplCopyWith(_$Payload_PubkeyHashImpl value,
          $Res Function(_$Payload_PubkeyHashImpl) then) =
      __$$Payload_PubkeyHashImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String pubkeyHash});
}

/// @nodoc
class __$$Payload_PubkeyHashImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_PubkeyHashImpl>
    implements _$$Payload_PubkeyHashImplCopyWith<$Res> {
  __$$Payload_PubkeyHashImplCopyWithImpl(_$Payload_PubkeyHashImpl _value,
      $Res Function(_$Payload_PubkeyHashImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? pubkeyHash = null,
  }) {
    return _then(_$Payload_PubkeyHashImpl(
      pubkeyHash: null == pubkeyHash
          ? _value.pubkeyHash
          : pubkeyHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Payload_PubkeyHashImpl extends Payload_PubkeyHash {
  const _$Payload_PubkeyHashImpl({required this.pubkeyHash}) : super._();

  @override
  final String pubkeyHash;

  @override
  String toString() {
    return 'Payload.pubkeyHash(pubkeyHash: $pubkeyHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_PubkeyHashImpl &&
            (identical(other.pubkeyHash, pubkeyHash) ||
                other.pubkeyHash == pubkeyHash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, pubkeyHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_PubkeyHashImplCopyWith<_$Payload_PubkeyHashImpl> get copyWith =>
      __$$Payload_PubkeyHashImplCopyWithImpl<_$Payload_PubkeyHashImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String pubkeyHash) pubkeyHash,
    required TResult Function(String scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return pubkeyHash(this.pubkeyHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String pubkeyHash)? pubkeyHash,
    TResult? Function(String scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return pubkeyHash?.call(this.pubkeyHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String pubkeyHash)? pubkeyHash,
    TResult Function(String scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (pubkeyHash != null) {
      return pubkeyHash(this.pubkeyHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return pubkeyHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return pubkeyHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (pubkeyHash != null) {
      return pubkeyHash(this);
    }
    return orElse();
  }
}

abstract class Payload_PubkeyHash extends Payload {
  const factory Payload_PubkeyHash({required final String pubkeyHash}) =
      _$Payload_PubkeyHashImpl;
  const Payload_PubkeyHash._() : super._();

  String get pubkeyHash;
  @JsonKey(ignore: true)
  _$$Payload_PubkeyHashImplCopyWith<_$Payload_PubkeyHashImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Payload_ScriptHashImplCopyWith<$Res> {
  factory _$$Payload_ScriptHashImplCopyWith(_$Payload_ScriptHashImpl value,
          $Res Function(_$Payload_ScriptHashImpl) then) =
      __$$Payload_ScriptHashImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String scriptHash});
}

/// @nodoc
class __$$Payload_ScriptHashImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_ScriptHashImpl>
    implements _$$Payload_ScriptHashImplCopyWith<$Res> {
  __$$Payload_ScriptHashImplCopyWithImpl(_$Payload_ScriptHashImpl _value,
      $Res Function(_$Payload_ScriptHashImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? scriptHash = null,
  }) {
    return _then(_$Payload_ScriptHashImpl(
      scriptHash: null == scriptHash
          ? _value.scriptHash
          : scriptHash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Payload_ScriptHashImpl extends Payload_ScriptHash {
  const _$Payload_ScriptHashImpl({required this.scriptHash}) : super._();

  @override
  final String scriptHash;

  @override
  String toString() {
    return 'Payload.scriptHash(scriptHash: $scriptHash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_ScriptHashImpl &&
            (identical(other.scriptHash, scriptHash) ||
                other.scriptHash == scriptHash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, scriptHash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_ScriptHashImplCopyWith<_$Payload_ScriptHashImpl> get copyWith =>
      __$$Payload_ScriptHashImplCopyWithImpl<_$Payload_ScriptHashImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String pubkeyHash) pubkeyHash,
    required TResult Function(String scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return scriptHash(this.scriptHash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String pubkeyHash)? pubkeyHash,
    TResult? Function(String scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return scriptHash?.call(this.scriptHash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String pubkeyHash)? pubkeyHash,
    TResult Function(String scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (scriptHash != null) {
      return scriptHash(this.scriptHash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return scriptHash(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return scriptHash?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (scriptHash != null) {
      return scriptHash(this);
    }
    return orElse();
  }
}

abstract class Payload_ScriptHash extends Payload {
  const factory Payload_ScriptHash({required final String scriptHash}) =
      _$Payload_ScriptHashImpl;
  const Payload_ScriptHash._() : super._();

  String get scriptHash;
  @JsonKey(ignore: true)
  _$$Payload_ScriptHashImplCopyWith<_$Payload_ScriptHashImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Payload_WitnessProgramImplCopyWith<$Res> {
  factory _$$Payload_WitnessProgramImplCopyWith(
          _$Payload_WitnessProgramImpl value,
          $Res Function(_$Payload_WitnessProgramImpl) then) =
      __$$Payload_WitnessProgramImplCopyWithImpl<$Res>;
  @useResult
  $Res call({WitnessVersion version, Uint8List program});
}

/// @nodoc
class __$$Payload_WitnessProgramImplCopyWithImpl<$Res>
    extends _$PayloadCopyWithImpl<$Res, _$Payload_WitnessProgramImpl>
    implements _$$Payload_WitnessProgramImplCopyWith<$Res> {
  __$$Payload_WitnessProgramImplCopyWithImpl(
      _$Payload_WitnessProgramImpl _value,
      $Res Function(_$Payload_WitnessProgramImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? version = null,
    Object? program = null,
  }) {
    return _then(_$Payload_WitnessProgramImpl(
      version: null == version
          ? _value.version
          : version // ignore: cast_nullable_to_non_nullable
              as WitnessVersion,
      program: null == program
          ? _value.program
          : program // ignore: cast_nullable_to_non_nullable
              as Uint8List,
    ));
  }
}

/// @nodoc

class _$Payload_WitnessProgramImpl extends Payload_WitnessProgram {
  const _$Payload_WitnessProgramImpl(
      {required this.version, required this.program})
      : super._();

  /// The witness program version.
  @override
  final WitnessVersion version;

  /// The witness program.
  @override
  final Uint8List program;

  @override
  String toString() {
    return 'Payload.witnessProgram(version: $version, program: $program)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Payload_WitnessProgramImpl &&
            (identical(other.version, version) || other.version == version) &&
            const DeepCollectionEquality().equals(other.program, program));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, version, const DeepCollectionEquality().hash(program));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Payload_WitnessProgramImplCopyWith<_$Payload_WitnessProgramImpl>
      get copyWith => __$$Payload_WitnessProgramImplCopyWithImpl<
          _$Payload_WitnessProgramImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String pubkeyHash) pubkeyHash,
    required TResult Function(String scriptHash) scriptHash,
    required TResult Function(WitnessVersion version, Uint8List program)
        witnessProgram,
  }) {
    return witnessProgram(version, program);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String pubkeyHash)? pubkeyHash,
    TResult? Function(String scriptHash)? scriptHash,
    TResult? Function(WitnessVersion version, Uint8List program)?
        witnessProgram,
  }) {
    return witnessProgram?.call(version, program);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String pubkeyHash)? pubkeyHash,
    TResult Function(String scriptHash)? scriptHash,
    TResult Function(WitnessVersion version, Uint8List program)? witnessProgram,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(version, program);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Payload_PubkeyHash value) pubkeyHash,
    required TResult Function(Payload_ScriptHash value) scriptHash,
    required TResult Function(Payload_WitnessProgram value) witnessProgram,
  }) {
    return witnessProgram(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult? Function(Payload_ScriptHash value)? scriptHash,
    TResult? Function(Payload_WitnessProgram value)? witnessProgram,
  }) {
    return witnessProgram?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Payload_PubkeyHash value)? pubkeyHash,
    TResult Function(Payload_ScriptHash value)? scriptHash,
    TResult Function(Payload_WitnessProgram value)? witnessProgram,
    required TResult orElse(),
  }) {
    if (witnessProgram != null) {
      return witnessProgram(this);
    }
    return orElse();
  }
}

abstract class Payload_WitnessProgram extends Payload {
  const factory Payload_WitnessProgram(
      {required final WitnessVersion version,
      required final Uint8List program}) = _$Payload_WitnessProgramImpl;
  const Payload_WitnessProgram._() : super._();

  /// The witness program version.
  WitnessVersion get version;

  /// The witness program.
  Uint8List get program;
  @JsonKey(ignore: true)
  _$$Payload_WitnessProgramImplCopyWith<_$Payload_WitnessProgramImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PkOrF {
  String get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) pubkey,
    required TResult Function(String value) xOnlyPubkey,
    required TResult Function(String value) fingerprint,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? pubkey,
    TResult? Function(String value)? xOnlyPubkey,
    TResult? Function(String value)? fingerprint,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? pubkey,
    TResult Function(String value)? xOnlyPubkey,
    TResult Function(String value)? fingerprint,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PkOrF_Pubkey value) pubkey,
    required TResult Function(PkOrF_XOnlyPubkey value) xOnlyPubkey,
    required TResult Function(PkOrF_Fingerprint value) fingerprint,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PkOrF_Pubkey value)? pubkey,
    TResult? Function(PkOrF_XOnlyPubkey value)? xOnlyPubkey,
    TResult? Function(PkOrF_Fingerprint value)? fingerprint,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PkOrF_Pubkey value)? pubkey,
    TResult Function(PkOrF_XOnlyPubkey value)? xOnlyPubkey,
    TResult Function(PkOrF_Fingerprint value)? fingerprint,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PkOrFCopyWith<PkOrF> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PkOrFCopyWith<$Res> {
  factory $PkOrFCopyWith(PkOrF value, $Res Function(PkOrF) then) =
      _$PkOrFCopyWithImpl<$Res, PkOrF>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$PkOrFCopyWithImpl<$Res, $Val extends PkOrF>
    implements $PkOrFCopyWith<$Res> {
  _$PkOrFCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PkOrF_PubkeyImplCopyWith<$Res>
    implements $PkOrFCopyWith<$Res> {
  factory _$$PkOrF_PubkeyImplCopyWith(
          _$PkOrF_PubkeyImpl value, $Res Function(_$PkOrF_PubkeyImpl) then) =
      __$$PkOrF_PubkeyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$PkOrF_PubkeyImplCopyWithImpl<$Res>
    extends _$PkOrFCopyWithImpl<$Res, _$PkOrF_PubkeyImpl>
    implements _$$PkOrF_PubkeyImplCopyWith<$Res> {
  __$$PkOrF_PubkeyImplCopyWithImpl(
      _$PkOrF_PubkeyImpl _value, $Res Function(_$PkOrF_PubkeyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$PkOrF_PubkeyImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PkOrF_PubkeyImpl extends PkOrF_Pubkey {
  const _$PkOrF_PubkeyImpl({required this.value}) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'PkOrF.pubkey(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PkOrF_PubkeyImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PkOrF_PubkeyImplCopyWith<_$PkOrF_PubkeyImpl> get copyWith =>
      __$$PkOrF_PubkeyImplCopyWithImpl<_$PkOrF_PubkeyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) pubkey,
    required TResult Function(String value) xOnlyPubkey,
    required TResult Function(String value) fingerprint,
  }) {
    return pubkey(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? pubkey,
    TResult? Function(String value)? xOnlyPubkey,
    TResult? Function(String value)? fingerprint,
  }) {
    return pubkey?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? pubkey,
    TResult Function(String value)? xOnlyPubkey,
    TResult Function(String value)? fingerprint,
    required TResult orElse(),
  }) {
    if (pubkey != null) {
      return pubkey(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PkOrF_Pubkey value) pubkey,
    required TResult Function(PkOrF_XOnlyPubkey value) xOnlyPubkey,
    required TResult Function(PkOrF_Fingerprint value) fingerprint,
  }) {
    return pubkey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PkOrF_Pubkey value)? pubkey,
    TResult? Function(PkOrF_XOnlyPubkey value)? xOnlyPubkey,
    TResult? Function(PkOrF_Fingerprint value)? fingerprint,
  }) {
    return pubkey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PkOrF_Pubkey value)? pubkey,
    TResult Function(PkOrF_XOnlyPubkey value)? xOnlyPubkey,
    TResult Function(PkOrF_Fingerprint value)? fingerprint,
    required TResult orElse(),
  }) {
    if (pubkey != null) {
      return pubkey(this);
    }
    return orElse();
  }
}

abstract class PkOrF_Pubkey extends PkOrF {
  const factory PkOrF_Pubkey({required final String value}) =
      _$PkOrF_PubkeyImpl;
  const PkOrF_Pubkey._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$PkOrF_PubkeyImplCopyWith<_$PkOrF_PubkeyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PkOrF_XOnlyPubkeyImplCopyWith<$Res>
    implements $PkOrFCopyWith<$Res> {
  factory _$$PkOrF_XOnlyPubkeyImplCopyWith(_$PkOrF_XOnlyPubkeyImpl value,
          $Res Function(_$PkOrF_XOnlyPubkeyImpl) then) =
      __$$PkOrF_XOnlyPubkeyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$PkOrF_XOnlyPubkeyImplCopyWithImpl<$Res>
    extends _$PkOrFCopyWithImpl<$Res, _$PkOrF_XOnlyPubkeyImpl>
    implements _$$PkOrF_XOnlyPubkeyImplCopyWith<$Res> {
  __$$PkOrF_XOnlyPubkeyImplCopyWithImpl(_$PkOrF_XOnlyPubkeyImpl _value,
      $Res Function(_$PkOrF_XOnlyPubkeyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$PkOrF_XOnlyPubkeyImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PkOrF_XOnlyPubkeyImpl extends PkOrF_XOnlyPubkey {
  const _$PkOrF_XOnlyPubkeyImpl({required this.value}) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'PkOrF.xOnlyPubkey(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PkOrF_XOnlyPubkeyImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PkOrF_XOnlyPubkeyImplCopyWith<_$PkOrF_XOnlyPubkeyImpl> get copyWith =>
      __$$PkOrF_XOnlyPubkeyImplCopyWithImpl<_$PkOrF_XOnlyPubkeyImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) pubkey,
    required TResult Function(String value) xOnlyPubkey,
    required TResult Function(String value) fingerprint,
  }) {
    return xOnlyPubkey(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? pubkey,
    TResult? Function(String value)? xOnlyPubkey,
    TResult? Function(String value)? fingerprint,
  }) {
    return xOnlyPubkey?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? pubkey,
    TResult Function(String value)? xOnlyPubkey,
    TResult Function(String value)? fingerprint,
    required TResult orElse(),
  }) {
    if (xOnlyPubkey != null) {
      return xOnlyPubkey(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PkOrF_Pubkey value) pubkey,
    required TResult Function(PkOrF_XOnlyPubkey value) xOnlyPubkey,
    required TResult Function(PkOrF_Fingerprint value) fingerprint,
  }) {
    return xOnlyPubkey(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PkOrF_Pubkey value)? pubkey,
    TResult? Function(PkOrF_XOnlyPubkey value)? xOnlyPubkey,
    TResult? Function(PkOrF_Fingerprint value)? fingerprint,
  }) {
    return xOnlyPubkey?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PkOrF_Pubkey value)? pubkey,
    TResult Function(PkOrF_XOnlyPubkey value)? xOnlyPubkey,
    TResult Function(PkOrF_Fingerprint value)? fingerprint,
    required TResult orElse(),
  }) {
    if (xOnlyPubkey != null) {
      return xOnlyPubkey(this);
    }
    return orElse();
  }
}

abstract class PkOrF_XOnlyPubkey extends PkOrF {
  const factory PkOrF_XOnlyPubkey({required final String value}) =
      _$PkOrF_XOnlyPubkeyImpl;
  const PkOrF_XOnlyPubkey._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$PkOrF_XOnlyPubkeyImplCopyWith<_$PkOrF_XOnlyPubkeyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PkOrF_FingerprintImplCopyWith<$Res>
    implements $PkOrFCopyWith<$Res> {
  factory _$$PkOrF_FingerprintImplCopyWith(_$PkOrF_FingerprintImpl value,
          $Res Function(_$PkOrF_FingerprintImpl) then) =
      __$$PkOrF_FingerprintImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$PkOrF_FingerprintImplCopyWithImpl<$Res>
    extends _$PkOrFCopyWithImpl<$Res, _$PkOrF_FingerprintImpl>
    implements _$$PkOrF_FingerprintImplCopyWith<$Res> {
  __$$PkOrF_FingerprintImplCopyWithImpl(_$PkOrF_FingerprintImpl _value,
      $Res Function(_$PkOrF_FingerprintImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$PkOrF_FingerprintImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PkOrF_FingerprintImpl extends PkOrF_Fingerprint {
  const _$PkOrF_FingerprintImpl({required this.value}) : super._();

  @override
  final String value;

  @override
  String toString() {
    return 'PkOrF.fingerprint(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PkOrF_FingerprintImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PkOrF_FingerprintImplCopyWith<_$PkOrF_FingerprintImpl> get copyWith =>
      __$$PkOrF_FingerprintImplCopyWithImpl<_$PkOrF_FingerprintImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String value) pubkey,
    required TResult Function(String value) xOnlyPubkey,
    required TResult Function(String value) fingerprint,
  }) {
    return fingerprint(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String value)? pubkey,
    TResult? Function(String value)? xOnlyPubkey,
    TResult? Function(String value)? fingerprint,
  }) {
    return fingerprint?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String value)? pubkey,
    TResult Function(String value)? xOnlyPubkey,
    TResult Function(String value)? fingerprint,
    required TResult orElse(),
  }) {
    if (fingerprint != null) {
      return fingerprint(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(PkOrF_Pubkey value) pubkey,
    required TResult Function(PkOrF_XOnlyPubkey value) xOnlyPubkey,
    required TResult Function(PkOrF_Fingerprint value) fingerprint,
  }) {
    return fingerprint(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(PkOrF_Pubkey value)? pubkey,
    TResult? Function(PkOrF_XOnlyPubkey value)? xOnlyPubkey,
    TResult? Function(PkOrF_Fingerprint value)? fingerprint,
  }) {
    return fingerprint?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(PkOrF_Pubkey value)? pubkey,
    TResult Function(PkOrF_XOnlyPubkey value)? xOnlyPubkey,
    TResult Function(PkOrF_Fingerprint value)? fingerprint,
    required TResult orElse(),
  }) {
    if (fingerprint != null) {
      return fingerprint(this);
    }
    return orElse();
  }
}

abstract class PkOrF_Fingerprint extends PkOrF {
  const factory PkOrF_Fingerprint({required final String value}) =
      _$PkOrF_FingerprintImpl;
  const PkOrF_Fingerprint._() : super._();

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$PkOrF_FingerprintImplCopyWith<_$PkOrF_FingerprintImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RbfValue {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RbfValueCopyWith<$Res> {
  factory $RbfValueCopyWith(RbfValue value, $Res Function(RbfValue) then) =
      _$RbfValueCopyWithImpl<$Res, RbfValue>;
}

/// @nodoc
class _$RbfValueCopyWithImpl<$Res, $Val extends RbfValue>
    implements $RbfValueCopyWith<$Res> {
  _$RbfValueCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$RbfValue_RbfDefaultImplCopyWith<$Res> {
  factory _$$RbfValue_RbfDefaultImplCopyWith(_$RbfValue_RbfDefaultImpl value,
          $Res Function(_$RbfValue_RbfDefaultImpl) then) =
      __$$RbfValue_RbfDefaultImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$RbfValue_RbfDefaultImplCopyWithImpl<$Res>
    extends _$RbfValueCopyWithImpl<$Res, _$RbfValue_RbfDefaultImpl>
    implements _$$RbfValue_RbfDefaultImplCopyWith<$Res> {
  __$$RbfValue_RbfDefaultImplCopyWithImpl(_$RbfValue_RbfDefaultImpl _value,
      $Res Function(_$RbfValue_RbfDefaultImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$RbfValue_RbfDefaultImpl extends RbfValue_RbfDefault {
  const _$RbfValue_RbfDefaultImpl() : super._();

  @override
  String toString() {
    return 'RbfValue.rbfDefault()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RbfValue_RbfDefaultImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) {
    return rbfDefault();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) {
    return rbfDefault?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) {
    if (rbfDefault != null) {
      return rbfDefault();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) {
    return rbfDefault(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) {
    return rbfDefault?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) {
    if (rbfDefault != null) {
      return rbfDefault(this);
    }
    return orElse();
  }
}

abstract class RbfValue_RbfDefault extends RbfValue {
  const factory RbfValue_RbfDefault() = _$RbfValue_RbfDefaultImpl;
  const RbfValue_RbfDefault._() : super._();
}

/// @nodoc
abstract class _$$RbfValue_ValueImplCopyWith<$Res> {
  factory _$$RbfValue_ValueImplCopyWith(_$RbfValue_ValueImpl value,
          $Res Function(_$RbfValue_ValueImpl) then) =
      __$$RbfValue_ValueImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$RbfValue_ValueImplCopyWithImpl<$Res>
    extends _$RbfValueCopyWithImpl<$Res, _$RbfValue_ValueImpl>
    implements _$$RbfValue_ValueImplCopyWith<$Res> {
  __$$RbfValue_ValueImplCopyWithImpl(
      _$RbfValue_ValueImpl _value, $Res Function(_$RbfValue_ValueImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$RbfValue_ValueImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$RbfValue_ValueImpl extends RbfValue_Value {
  const _$RbfValue_ValueImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'RbfValue.value(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RbfValue_ValueImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$RbfValue_ValueImplCopyWith<_$RbfValue_ValueImpl> get copyWith =>
      __$$RbfValue_ValueImplCopyWithImpl<_$RbfValue_ValueImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() rbfDefault,
    required TResult Function(int field0) value,
  }) {
    return value(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? rbfDefault,
    TResult? Function(int field0)? value,
  }) {
    return value?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? rbfDefault,
    TResult Function(int field0)? value,
    required TResult orElse(),
  }) {
    if (value != null) {
      return value(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(RbfValue_RbfDefault value) rbfDefault,
    required TResult Function(RbfValue_Value value) value,
  }) {
    return value(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult? Function(RbfValue_Value value)? value,
  }) {
    return value?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(RbfValue_RbfDefault value)? rbfDefault,
    TResult Function(RbfValue_Value value)? value,
    required TResult orElse(),
  }) {
    if (value != null) {
      return value(this);
    }
    return orElse();
  }
}

abstract class RbfValue_Value extends RbfValue {
  const factory RbfValue_Value(final int field0) = _$RbfValue_ValueImpl;
  const RbfValue_Value._() : super._();

  int get field0;
  @JsonKey(ignore: true)
  _$$RbfValue_ValueImplCopyWith<_$RbfValue_ValueImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Satisfaction {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<int, List<Condition>> conditions)
        partial,
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<Uint32List, List<Condition>> conditions)
        partialComplete,
    required TResult Function(Condition condition) complete,
    required TResult Function(String msg) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult? Function(Condition condition)? complete,
    TResult? Function(String msg)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult Function(Condition condition)? complete,
    TResult Function(String msg)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Satisfaction_Partial value) partial,
    required TResult Function(Satisfaction_PartialComplete value)
        partialComplete,
    required TResult Function(Satisfaction_Complete value) complete,
    required TResult Function(Satisfaction_None value) none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Satisfaction_Partial value)? partial,
    TResult? Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult? Function(Satisfaction_Complete value)? complete,
    TResult? Function(Satisfaction_None value)? none,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Satisfaction_Partial value)? partial,
    TResult Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult Function(Satisfaction_Complete value)? complete,
    TResult Function(Satisfaction_None value)? none,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SatisfactionCopyWith<$Res> {
  factory $SatisfactionCopyWith(
          Satisfaction value, $Res Function(Satisfaction) then) =
      _$SatisfactionCopyWithImpl<$Res, Satisfaction>;
}

/// @nodoc
class _$SatisfactionCopyWithImpl<$Res, $Val extends Satisfaction>
    implements $SatisfactionCopyWith<$Res> {
  _$SatisfactionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$Satisfaction_PartialImplCopyWith<$Res> {
  factory _$$Satisfaction_PartialImplCopyWith(_$Satisfaction_PartialImpl value,
          $Res Function(_$Satisfaction_PartialImpl) then) =
      __$$Satisfaction_PartialImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {BigInt n,
      BigInt m,
      Uint64List items,
      bool? sorted,
      Map<int, List<Condition>> conditions});
}

/// @nodoc
class __$$Satisfaction_PartialImplCopyWithImpl<$Res>
    extends _$SatisfactionCopyWithImpl<$Res, _$Satisfaction_PartialImpl>
    implements _$$Satisfaction_PartialImplCopyWith<$Res> {
  __$$Satisfaction_PartialImplCopyWithImpl(_$Satisfaction_PartialImpl _value,
      $Res Function(_$Satisfaction_PartialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? n = null,
    Object? m = null,
    Object? items = null,
    Object? sorted = freezed,
    Object? conditions = null,
  }) {
    return _then(_$Satisfaction_PartialImpl(
      n: null == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as BigInt,
      m: null == m
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as BigInt,
      items: null == items
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as Uint64List,
      sorted: freezed == sorted
          ? _value.sorted
          : sorted // ignore: cast_nullable_to_non_nullable
              as bool?,
      conditions: null == conditions
          ? _value._conditions
          : conditions // ignore: cast_nullable_to_non_nullable
              as Map<int, List<Condition>>,
    ));
  }
}

/// @nodoc

class _$Satisfaction_PartialImpl extends Satisfaction_Partial {
  const _$Satisfaction_PartialImpl(
      {required this.n,
      required this.m,
      required this.items,
      this.sorted,
      required final Map<int, List<Condition>> conditions})
      : _conditions = conditions,
        super._();

  @override
  final BigInt n;
  @override
  final BigInt m;
  @override
  final Uint64List items;
  @override
  final bool? sorted;
  final Map<int, List<Condition>> _conditions;
  @override
  Map<int, List<Condition>> get conditions {
    if (_conditions is EqualUnmodifiableMapView) return _conditions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_conditions);
  }

  @override
  String toString() {
    return 'Satisfaction.partial(n: $n, m: $m, items: $items, sorted: $sorted, conditions: $conditions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Satisfaction_PartialImpl &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.m, m) || other.m == m) &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.sorted, sorted) || other.sorted == sorted) &&
            const DeepCollectionEquality()
                .equals(other._conditions, _conditions));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      n,
      m,
      const DeepCollectionEquality().hash(items),
      sorted,
      const DeepCollectionEquality().hash(_conditions));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Satisfaction_PartialImplCopyWith<_$Satisfaction_PartialImpl>
      get copyWith =>
          __$$Satisfaction_PartialImplCopyWithImpl<_$Satisfaction_PartialImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<int, List<Condition>> conditions)
        partial,
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<Uint32List, List<Condition>> conditions)
        partialComplete,
    required TResult Function(Condition condition) complete,
    required TResult Function(String msg) none,
  }) {
    return partial(n, m, items, sorted, conditions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult? Function(Condition condition)? complete,
    TResult? Function(String msg)? none,
  }) {
    return partial?.call(n, m, items, sorted, conditions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult Function(Condition condition)? complete,
    TResult Function(String msg)? none,
    required TResult orElse(),
  }) {
    if (partial != null) {
      return partial(n, m, items, sorted, conditions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Satisfaction_Partial value) partial,
    required TResult Function(Satisfaction_PartialComplete value)
        partialComplete,
    required TResult Function(Satisfaction_Complete value) complete,
    required TResult Function(Satisfaction_None value) none,
  }) {
    return partial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Satisfaction_Partial value)? partial,
    TResult? Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult? Function(Satisfaction_Complete value)? complete,
    TResult? Function(Satisfaction_None value)? none,
  }) {
    return partial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Satisfaction_Partial value)? partial,
    TResult Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult Function(Satisfaction_Complete value)? complete,
    TResult Function(Satisfaction_None value)? none,
    required TResult orElse(),
  }) {
    if (partial != null) {
      return partial(this);
    }
    return orElse();
  }
}

abstract class Satisfaction_Partial extends Satisfaction {
  const factory Satisfaction_Partial(
          {required final BigInt n,
          required final BigInt m,
          required final Uint64List items,
          final bool? sorted,
          required final Map<int, List<Condition>> conditions}) =
      _$Satisfaction_PartialImpl;
  const Satisfaction_Partial._() : super._();

  BigInt get n;
  BigInt get m;
  Uint64List get items;
  bool? get sorted;
  Map<int, List<Condition>> get conditions;
  @JsonKey(ignore: true)
  _$$Satisfaction_PartialImplCopyWith<_$Satisfaction_PartialImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Satisfaction_PartialCompleteImplCopyWith<$Res> {
  factory _$$Satisfaction_PartialCompleteImplCopyWith(
          _$Satisfaction_PartialCompleteImpl value,
          $Res Function(_$Satisfaction_PartialCompleteImpl) then) =
      __$$Satisfaction_PartialCompleteImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {BigInt n,
      BigInt m,
      Uint64List items,
      bool? sorted,
      Map<Uint32List, List<Condition>> conditions});
}

/// @nodoc
class __$$Satisfaction_PartialCompleteImplCopyWithImpl<$Res>
    extends _$SatisfactionCopyWithImpl<$Res, _$Satisfaction_PartialCompleteImpl>
    implements _$$Satisfaction_PartialCompleteImplCopyWith<$Res> {
  __$$Satisfaction_PartialCompleteImplCopyWithImpl(
      _$Satisfaction_PartialCompleteImpl _value,
      $Res Function(_$Satisfaction_PartialCompleteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? n = null,
    Object? m = null,
    Object? items = null,
    Object? sorted = freezed,
    Object? conditions = null,
  }) {
    return _then(_$Satisfaction_PartialCompleteImpl(
      n: null == n
          ? _value.n
          : n // ignore: cast_nullable_to_non_nullable
              as BigInt,
      m: null == m
          ? _value.m
          : m // ignore: cast_nullable_to_non_nullable
              as BigInt,
      items: null == items
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as Uint64List,
      sorted: freezed == sorted
          ? _value.sorted
          : sorted // ignore: cast_nullable_to_non_nullable
              as bool?,
      conditions: null == conditions
          ? _value._conditions
          : conditions // ignore: cast_nullable_to_non_nullable
              as Map<Uint32List, List<Condition>>,
    ));
  }
}

/// @nodoc

class _$Satisfaction_PartialCompleteImpl extends Satisfaction_PartialComplete {
  const _$Satisfaction_PartialCompleteImpl(
      {required this.n,
      required this.m,
      required this.items,
      this.sorted,
      required final Map<Uint32List, List<Condition>> conditions})
      : _conditions = conditions,
        super._();

  @override
  final BigInt n;
  @override
  final BigInt m;
  @override
  final Uint64List items;
  @override
  final bool? sorted;
  final Map<Uint32List, List<Condition>> _conditions;
  @override
  Map<Uint32List, List<Condition>> get conditions {
    if (_conditions is EqualUnmodifiableMapView) return _conditions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_conditions);
  }

  @override
  String toString() {
    return 'Satisfaction.partialComplete(n: $n, m: $m, items: $items, sorted: $sorted, conditions: $conditions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Satisfaction_PartialCompleteImpl &&
            (identical(other.n, n) || other.n == n) &&
            (identical(other.m, m) || other.m == m) &&
            const DeepCollectionEquality().equals(other.items, items) &&
            (identical(other.sorted, sorted) || other.sorted == sorted) &&
            const DeepCollectionEquality()
                .equals(other._conditions, _conditions));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      n,
      m,
      const DeepCollectionEquality().hash(items),
      sorted,
      const DeepCollectionEquality().hash(_conditions));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Satisfaction_PartialCompleteImplCopyWith<
          _$Satisfaction_PartialCompleteImpl>
      get copyWith => __$$Satisfaction_PartialCompleteImplCopyWithImpl<
          _$Satisfaction_PartialCompleteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<int, List<Condition>> conditions)
        partial,
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<Uint32List, List<Condition>> conditions)
        partialComplete,
    required TResult Function(Condition condition) complete,
    required TResult Function(String msg) none,
  }) {
    return partialComplete(n, m, items, sorted, conditions);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult? Function(Condition condition)? complete,
    TResult? Function(String msg)? none,
  }) {
    return partialComplete?.call(n, m, items, sorted, conditions);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult Function(Condition condition)? complete,
    TResult Function(String msg)? none,
    required TResult orElse(),
  }) {
    if (partialComplete != null) {
      return partialComplete(n, m, items, sorted, conditions);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Satisfaction_Partial value) partial,
    required TResult Function(Satisfaction_PartialComplete value)
        partialComplete,
    required TResult Function(Satisfaction_Complete value) complete,
    required TResult Function(Satisfaction_None value) none,
  }) {
    return partialComplete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Satisfaction_Partial value)? partial,
    TResult? Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult? Function(Satisfaction_Complete value)? complete,
    TResult? Function(Satisfaction_None value)? none,
  }) {
    return partialComplete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Satisfaction_Partial value)? partial,
    TResult Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult Function(Satisfaction_Complete value)? complete,
    TResult Function(Satisfaction_None value)? none,
    required TResult orElse(),
  }) {
    if (partialComplete != null) {
      return partialComplete(this);
    }
    return orElse();
  }
}

abstract class Satisfaction_PartialComplete extends Satisfaction {
  const factory Satisfaction_PartialComplete(
          {required final BigInt n,
          required final BigInt m,
          required final Uint64List items,
          final bool? sorted,
          required final Map<Uint32List, List<Condition>> conditions}) =
      _$Satisfaction_PartialCompleteImpl;
  const Satisfaction_PartialComplete._() : super._();

  BigInt get n;
  BigInt get m;
  Uint64List get items;
  bool? get sorted;
  Map<Uint32List, List<Condition>> get conditions;
  @JsonKey(ignore: true)
  _$$Satisfaction_PartialCompleteImplCopyWith<
          _$Satisfaction_PartialCompleteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Satisfaction_CompleteImplCopyWith<$Res> {
  factory _$$Satisfaction_CompleteImplCopyWith(
          _$Satisfaction_CompleteImpl value,
          $Res Function(_$Satisfaction_CompleteImpl) then) =
      __$$Satisfaction_CompleteImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Condition condition});
}

/// @nodoc
class __$$Satisfaction_CompleteImplCopyWithImpl<$Res>
    extends _$SatisfactionCopyWithImpl<$Res, _$Satisfaction_CompleteImpl>
    implements _$$Satisfaction_CompleteImplCopyWith<$Res> {
  __$$Satisfaction_CompleteImplCopyWithImpl(_$Satisfaction_CompleteImpl _value,
      $Res Function(_$Satisfaction_CompleteImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? condition = null,
  }) {
    return _then(_$Satisfaction_CompleteImpl(
      condition: null == condition
          ? _value.condition
          : condition // ignore: cast_nullable_to_non_nullable
              as Condition,
    ));
  }
}

/// @nodoc

class _$Satisfaction_CompleteImpl extends Satisfaction_Complete {
  const _$Satisfaction_CompleteImpl({required this.condition}) : super._();

  @override
  final Condition condition;

  @override
  String toString() {
    return 'Satisfaction.complete(condition: $condition)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Satisfaction_CompleteImpl &&
            (identical(other.condition, condition) ||
                other.condition == condition));
  }

  @override
  int get hashCode => Object.hash(runtimeType, condition);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Satisfaction_CompleteImplCopyWith<_$Satisfaction_CompleteImpl>
      get copyWith => __$$Satisfaction_CompleteImplCopyWithImpl<
          _$Satisfaction_CompleteImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<int, List<Condition>> conditions)
        partial,
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<Uint32List, List<Condition>> conditions)
        partialComplete,
    required TResult Function(Condition condition) complete,
    required TResult Function(String msg) none,
  }) {
    return complete(condition);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult? Function(Condition condition)? complete,
    TResult? Function(String msg)? none,
  }) {
    return complete?.call(condition);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult Function(Condition condition)? complete,
    TResult Function(String msg)? none,
    required TResult orElse(),
  }) {
    if (complete != null) {
      return complete(condition);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Satisfaction_Partial value) partial,
    required TResult Function(Satisfaction_PartialComplete value)
        partialComplete,
    required TResult Function(Satisfaction_Complete value) complete,
    required TResult Function(Satisfaction_None value) none,
  }) {
    return complete(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Satisfaction_Partial value)? partial,
    TResult? Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult? Function(Satisfaction_Complete value)? complete,
    TResult? Function(Satisfaction_None value)? none,
  }) {
    return complete?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Satisfaction_Partial value)? partial,
    TResult Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult Function(Satisfaction_Complete value)? complete,
    TResult Function(Satisfaction_None value)? none,
    required TResult orElse(),
  }) {
    if (complete != null) {
      return complete(this);
    }
    return orElse();
  }
}

abstract class Satisfaction_Complete extends Satisfaction {
  const factory Satisfaction_Complete({required final Condition condition}) =
      _$Satisfaction_CompleteImpl;
  const Satisfaction_Complete._() : super._();

  Condition get condition;
  @JsonKey(ignore: true)
  _$$Satisfaction_CompleteImplCopyWith<_$Satisfaction_CompleteImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Satisfaction_NoneImplCopyWith<$Res> {
  factory _$$Satisfaction_NoneImplCopyWith(_$Satisfaction_NoneImpl value,
          $Res Function(_$Satisfaction_NoneImpl) then) =
      __$$Satisfaction_NoneImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String msg});
}

/// @nodoc
class __$$Satisfaction_NoneImplCopyWithImpl<$Res>
    extends _$SatisfactionCopyWithImpl<$Res, _$Satisfaction_NoneImpl>
    implements _$$Satisfaction_NoneImplCopyWith<$Res> {
  __$$Satisfaction_NoneImplCopyWithImpl(_$Satisfaction_NoneImpl _value,
      $Res Function(_$Satisfaction_NoneImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? msg = null,
  }) {
    return _then(_$Satisfaction_NoneImpl(
      msg: null == msg
          ? _value.msg
          : msg // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$Satisfaction_NoneImpl extends Satisfaction_None {
  const _$Satisfaction_NoneImpl({required this.msg}) : super._();

  @override
  final String msg;

  @override
  String toString() {
    return 'Satisfaction.none(msg: $msg)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Satisfaction_NoneImpl &&
            (identical(other.msg, msg) || other.msg == msg));
  }

  @override
  int get hashCode => Object.hash(runtimeType, msg);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Satisfaction_NoneImplCopyWith<_$Satisfaction_NoneImpl> get copyWith =>
      __$$Satisfaction_NoneImplCopyWithImpl<_$Satisfaction_NoneImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<int, List<Condition>> conditions)
        partial,
    required TResult Function(BigInt n, BigInt m, Uint64List items,
            bool? sorted, Map<Uint32List, List<Condition>> conditions)
        partialComplete,
    required TResult Function(Condition condition) complete,
    required TResult Function(String msg) none,
  }) {
    return none(msg);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult? Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult? Function(Condition condition)? complete,
    TResult? Function(String msg)? none,
  }) {
    return none?.call(msg);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<int, List<Condition>> conditions)?
        partial,
    TResult Function(BigInt n, BigInt m, Uint64List items, bool? sorted,
            Map<Uint32List, List<Condition>> conditions)?
        partialComplete,
    TResult Function(Condition condition)? complete,
    TResult Function(String msg)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(msg);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Satisfaction_Partial value) partial,
    required TResult Function(Satisfaction_PartialComplete value)
        partialComplete,
    required TResult Function(Satisfaction_Complete value) complete,
    required TResult Function(Satisfaction_None value) none,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(Satisfaction_Partial value)? partial,
    TResult? Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult? Function(Satisfaction_Complete value)? complete,
    TResult? Function(Satisfaction_None value)? none,
  }) {
    return none?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Satisfaction_Partial value)? partial,
    TResult Function(Satisfaction_PartialComplete value)? partialComplete,
    TResult Function(Satisfaction_Complete value)? complete,
    TResult Function(Satisfaction_None value)? none,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class Satisfaction_None extends Satisfaction {
  const factory Satisfaction_None({required final String msg}) =
      _$Satisfaction_NoneImpl;
  const Satisfaction_None._() : super._();

  String get msg;
  @JsonKey(ignore: true)
  _$$Satisfaction_NoneImplCopyWith<_$Satisfaction_NoneImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SatisfiableItem {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SatisfiableItemCopyWith<$Res> {
  factory $SatisfiableItemCopyWith(
          SatisfiableItem value, $Res Function(SatisfiableItem) then) =
      _$SatisfiableItemCopyWithImpl<$Res, SatisfiableItem>;
}

/// @nodoc
class _$SatisfiableItemCopyWithImpl<$Res, $Val extends SatisfiableItem>
    implements $SatisfiableItemCopyWith<$Res> {
  _$SatisfiableItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SatisfiableItem_EcdsaSignatureImplCopyWith<$Res> {
  factory _$$SatisfiableItem_EcdsaSignatureImplCopyWith(
          _$SatisfiableItem_EcdsaSignatureImpl value,
          $Res Function(_$SatisfiableItem_EcdsaSignatureImpl) then) =
      __$$SatisfiableItem_EcdsaSignatureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PkOrF key});

  $PkOrFCopyWith<$Res> get key;
}

/// @nodoc
class __$$SatisfiableItem_EcdsaSignatureImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res,
        _$SatisfiableItem_EcdsaSignatureImpl>
    implements _$$SatisfiableItem_EcdsaSignatureImplCopyWith<$Res> {
  __$$SatisfiableItem_EcdsaSignatureImplCopyWithImpl(
      _$SatisfiableItem_EcdsaSignatureImpl _value,
      $Res Function(_$SatisfiableItem_EcdsaSignatureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$SatisfiableItem_EcdsaSignatureImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as PkOrF,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PkOrFCopyWith<$Res> get key {
    return $PkOrFCopyWith<$Res>(_value.key, (value) {
      return _then(_value.copyWith(key: value));
    });
  }
}

/// @nodoc

class _$SatisfiableItem_EcdsaSignatureImpl
    extends SatisfiableItem_EcdsaSignature {
  const _$SatisfiableItem_EcdsaSignatureImpl({required this.key}) : super._();

  @override
  final PkOrF key;

  @override
  String toString() {
    return 'SatisfiableItem.ecdsaSignature(key: $key)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_EcdsaSignatureImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_EcdsaSignatureImplCopyWith<
          _$SatisfiableItem_EcdsaSignatureImpl>
      get copyWith => __$$SatisfiableItem_EcdsaSignatureImplCopyWithImpl<
          _$SatisfiableItem_EcdsaSignatureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return ecdsaSignature(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return ecdsaSignature?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (ecdsaSignature != null) {
      return ecdsaSignature(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return ecdsaSignature(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return ecdsaSignature?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (ecdsaSignature != null) {
      return ecdsaSignature(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_EcdsaSignature extends SatisfiableItem {
  const factory SatisfiableItem_EcdsaSignature({required final PkOrF key}) =
      _$SatisfiableItem_EcdsaSignatureImpl;
  const SatisfiableItem_EcdsaSignature._() : super._();

  PkOrF get key;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_EcdsaSignatureImplCopyWith<
          _$SatisfiableItem_EcdsaSignatureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_SchnorrSignatureImplCopyWith<$Res> {
  factory _$$SatisfiableItem_SchnorrSignatureImplCopyWith(
          _$SatisfiableItem_SchnorrSignatureImpl value,
          $Res Function(_$SatisfiableItem_SchnorrSignatureImpl) then) =
      __$$SatisfiableItem_SchnorrSignatureImplCopyWithImpl<$Res>;
  @useResult
  $Res call({PkOrF key});

  $PkOrFCopyWith<$Res> get key;
}

/// @nodoc
class __$$SatisfiableItem_SchnorrSignatureImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res,
        _$SatisfiableItem_SchnorrSignatureImpl>
    implements _$$SatisfiableItem_SchnorrSignatureImplCopyWith<$Res> {
  __$$SatisfiableItem_SchnorrSignatureImplCopyWithImpl(
      _$SatisfiableItem_SchnorrSignatureImpl _value,
      $Res Function(_$SatisfiableItem_SchnorrSignatureImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
  }) {
    return _then(_$SatisfiableItem_SchnorrSignatureImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as PkOrF,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $PkOrFCopyWith<$Res> get key {
    return $PkOrFCopyWith<$Res>(_value.key, (value) {
      return _then(_value.copyWith(key: value));
    });
  }
}

/// @nodoc

class _$SatisfiableItem_SchnorrSignatureImpl
    extends SatisfiableItem_SchnorrSignature {
  const _$SatisfiableItem_SchnorrSignatureImpl({required this.key}) : super._();

  @override
  final PkOrF key;

  @override
  String toString() {
    return 'SatisfiableItem.schnorrSignature(key: $key)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_SchnorrSignatureImpl &&
            (identical(other.key, key) || other.key == key));
  }

  @override
  int get hashCode => Object.hash(runtimeType, key);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_SchnorrSignatureImplCopyWith<
          _$SatisfiableItem_SchnorrSignatureImpl>
      get copyWith => __$$SatisfiableItem_SchnorrSignatureImplCopyWithImpl<
          _$SatisfiableItem_SchnorrSignatureImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return schnorrSignature(key);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return schnorrSignature?.call(key);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (schnorrSignature != null) {
      return schnorrSignature(key);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return schnorrSignature(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return schnorrSignature?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (schnorrSignature != null) {
      return schnorrSignature(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_SchnorrSignature extends SatisfiableItem {
  const factory SatisfiableItem_SchnorrSignature({required final PkOrF key}) =
      _$SatisfiableItem_SchnorrSignatureImpl;
  const SatisfiableItem_SchnorrSignature._() : super._();

  PkOrF get key;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_SchnorrSignatureImplCopyWith<
          _$SatisfiableItem_SchnorrSignatureImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_Sha256PreimageImplCopyWith<$Res> {
  factory _$$SatisfiableItem_Sha256PreimageImplCopyWith(
          _$SatisfiableItem_Sha256PreimageImpl value,
          $Res Function(_$SatisfiableItem_Sha256PreimageImpl) then) =
      __$$SatisfiableItem_Sha256PreimageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String hash});
}

/// @nodoc
class __$$SatisfiableItem_Sha256PreimageImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res,
        _$SatisfiableItem_Sha256PreimageImpl>
    implements _$$SatisfiableItem_Sha256PreimageImplCopyWith<$Res> {
  __$$SatisfiableItem_Sha256PreimageImplCopyWithImpl(
      _$SatisfiableItem_Sha256PreimageImpl _value,
      $Res Function(_$SatisfiableItem_Sha256PreimageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hash = null,
  }) {
    return _then(_$SatisfiableItem_Sha256PreimageImpl(
      hash: null == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SatisfiableItem_Sha256PreimageImpl
    extends SatisfiableItem_Sha256Preimage {
  const _$SatisfiableItem_Sha256PreimageImpl({required this.hash}) : super._();

  @override
  final String hash;

  @override
  String toString() {
    return 'SatisfiableItem.sha256Preimage(hash: $hash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_Sha256PreimageImpl &&
            (identical(other.hash, hash) || other.hash == hash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, hash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_Sha256PreimageImplCopyWith<
          _$SatisfiableItem_Sha256PreimageImpl>
      get copyWith => __$$SatisfiableItem_Sha256PreimageImplCopyWithImpl<
          _$SatisfiableItem_Sha256PreimageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return sha256Preimage(hash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return sha256Preimage?.call(hash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (sha256Preimage != null) {
      return sha256Preimage(hash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return sha256Preimage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return sha256Preimage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (sha256Preimage != null) {
      return sha256Preimage(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_Sha256Preimage extends SatisfiableItem {
  const factory SatisfiableItem_Sha256Preimage({required final String hash}) =
      _$SatisfiableItem_Sha256PreimageImpl;
  const SatisfiableItem_Sha256Preimage._() : super._();

  String get hash;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_Sha256PreimageImplCopyWith<
          _$SatisfiableItem_Sha256PreimageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_Hash256PreimageImplCopyWith<$Res> {
  factory _$$SatisfiableItem_Hash256PreimageImplCopyWith(
          _$SatisfiableItem_Hash256PreimageImpl value,
          $Res Function(_$SatisfiableItem_Hash256PreimageImpl) then) =
      __$$SatisfiableItem_Hash256PreimageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String hash});
}

/// @nodoc
class __$$SatisfiableItem_Hash256PreimageImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res,
        _$SatisfiableItem_Hash256PreimageImpl>
    implements _$$SatisfiableItem_Hash256PreimageImplCopyWith<$Res> {
  __$$SatisfiableItem_Hash256PreimageImplCopyWithImpl(
      _$SatisfiableItem_Hash256PreimageImpl _value,
      $Res Function(_$SatisfiableItem_Hash256PreimageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hash = null,
  }) {
    return _then(_$SatisfiableItem_Hash256PreimageImpl(
      hash: null == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SatisfiableItem_Hash256PreimageImpl
    extends SatisfiableItem_Hash256Preimage {
  const _$SatisfiableItem_Hash256PreimageImpl({required this.hash}) : super._();

  @override
  final String hash;

  @override
  String toString() {
    return 'SatisfiableItem.hash256Preimage(hash: $hash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_Hash256PreimageImpl &&
            (identical(other.hash, hash) || other.hash == hash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, hash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_Hash256PreimageImplCopyWith<
          _$SatisfiableItem_Hash256PreimageImpl>
      get copyWith => __$$SatisfiableItem_Hash256PreimageImplCopyWithImpl<
          _$SatisfiableItem_Hash256PreimageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return hash256Preimage(hash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return hash256Preimage?.call(hash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (hash256Preimage != null) {
      return hash256Preimage(hash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return hash256Preimage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return hash256Preimage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (hash256Preimage != null) {
      return hash256Preimage(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_Hash256Preimage extends SatisfiableItem {
  const factory SatisfiableItem_Hash256Preimage({required final String hash}) =
      _$SatisfiableItem_Hash256PreimageImpl;
  const SatisfiableItem_Hash256Preimage._() : super._();

  String get hash;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_Hash256PreimageImplCopyWith<
          _$SatisfiableItem_Hash256PreimageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_Ripemd160PreimageImplCopyWith<$Res> {
  factory _$$SatisfiableItem_Ripemd160PreimageImplCopyWith(
          _$SatisfiableItem_Ripemd160PreimageImpl value,
          $Res Function(_$SatisfiableItem_Ripemd160PreimageImpl) then) =
      __$$SatisfiableItem_Ripemd160PreimageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String hash});
}

/// @nodoc
class __$$SatisfiableItem_Ripemd160PreimageImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res,
        _$SatisfiableItem_Ripemd160PreimageImpl>
    implements _$$SatisfiableItem_Ripemd160PreimageImplCopyWith<$Res> {
  __$$SatisfiableItem_Ripemd160PreimageImplCopyWithImpl(
      _$SatisfiableItem_Ripemd160PreimageImpl _value,
      $Res Function(_$SatisfiableItem_Ripemd160PreimageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hash = null,
  }) {
    return _then(_$SatisfiableItem_Ripemd160PreimageImpl(
      hash: null == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SatisfiableItem_Ripemd160PreimageImpl
    extends SatisfiableItem_Ripemd160Preimage {
  const _$SatisfiableItem_Ripemd160PreimageImpl({required this.hash})
      : super._();

  @override
  final String hash;

  @override
  String toString() {
    return 'SatisfiableItem.ripemd160Preimage(hash: $hash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_Ripemd160PreimageImpl &&
            (identical(other.hash, hash) || other.hash == hash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, hash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_Ripemd160PreimageImplCopyWith<
          _$SatisfiableItem_Ripemd160PreimageImpl>
      get copyWith => __$$SatisfiableItem_Ripemd160PreimageImplCopyWithImpl<
          _$SatisfiableItem_Ripemd160PreimageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return ripemd160Preimage(hash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return ripemd160Preimage?.call(hash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (ripemd160Preimage != null) {
      return ripemd160Preimage(hash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return ripemd160Preimage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return ripemd160Preimage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (ripemd160Preimage != null) {
      return ripemd160Preimage(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_Ripemd160Preimage extends SatisfiableItem {
  const factory SatisfiableItem_Ripemd160Preimage(
      {required final String hash}) = _$SatisfiableItem_Ripemd160PreimageImpl;
  const SatisfiableItem_Ripemd160Preimage._() : super._();

  String get hash;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_Ripemd160PreimageImplCopyWith<
          _$SatisfiableItem_Ripemd160PreimageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_Hash160PreimageImplCopyWith<$Res> {
  factory _$$SatisfiableItem_Hash160PreimageImplCopyWith(
          _$SatisfiableItem_Hash160PreimageImpl value,
          $Res Function(_$SatisfiableItem_Hash160PreimageImpl) then) =
      __$$SatisfiableItem_Hash160PreimageImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String hash});
}

/// @nodoc
class __$$SatisfiableItem_Hash160PreimageImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res,
        _$SatisfiableItem_Hash160PreimageImpl>
    implements _$$SatisfiableItem_Hash160PreimageImplCopyWith<$Res> {
  __$$SatisfiableItem_Hash160PreimageImplCopyWithImpl(
      _$SatisfiableItem_Hash160PreimageImpl _value,
      $Res Function(_$SatisfiableItem_Hash160PreimageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? hash = null,
  }) {
    return _then(_$SatisfiableItem_Hash160PreimageImpl(
      hash: null == hash
          ? _value.hash
          : hash // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$SatisfiableItem_Hash160PreimageImpl
    extends SatisfiableItem_Hash160Preimage {
  const _$SatisfiableItem_Hash160PreimageImpl({required this.hash}) : super._();

  @override
  final String hash;

  @override
  String toString() {
    return 'SatisfiableItem.hash160Preimage(hash: $hash)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_Hash160PreimageImpl &&
            (identical(other.hash, hash) || other.hash == hash));
  }

  @override
  int get hashCode => Object.hash(runtimeType, hash);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_Hash160PreimageImplCopyWith<
          _$SatisfiableItem_Hash160PreimageImpl>
      get copyWith => __$$SatisfiableItem_Hash160PreimageImplCopyWithImpl<
          _$SatisfiableItem_Hash160PreimageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return hash160Preimage(hash);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return hash160Preimage?.call(hash);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (hash160Preimage != null) {
      return hash160Preimage(hash);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return hash160Preimage(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return hash160Preimage?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (hash160Preimage != null) {
      return hash160Preimage(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_Hash160Preimage extends SatisfiableItem {
  const factory SatisfiableItem_Hash160Preimage({required final String hash}) =
      _$SatisfiableItem_Hash160PreimageImpl;
  const SatisfiableItem_Hash160Preimage._() : super._();

  String get hash;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_Hash160PreimageImplCopyWith<
          _$SatisfiableItem_Hash160PreimageImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_AbsoluteTimelockImplCopyWith<$Res> {
  factory _$$SatisfiableItem_AbsoluteTimelockImplCopyWith(
          _$SatisfiableItem_AbsoluteTimelockImpl value,
          $Res Function(_$SatisfiableItem_AbsoluteTimelockImpl) then) =
      __$$SatisfiableItem_AbsoluteTimelockImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LockTime value});

  $LockTimeCopyWith<$Res> get value;
}

/// @nodoc
class __$$SatisfiableItem_AbsoluteTimelockImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res,
        _$SatisfiableItem_AbsoluteTimelockImpl>
    implements _$$SatisfiableItem_AbsoluteTimelockImplCopyWith<$Res> {
  __$$SatisfiableItem_AbsoluteTimelockImplCopyWithImpl(
      _$SatisfiableItem_AbsoluteTimelockImpl _value,
      $Res Function(_$SatisfiableItem_AbsoluteTimelockImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$SatisfiableItem_AbsoluteTimelockImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as LockTime,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $LockTimeCopyWith<$Res> get value {
    return $LockTimeCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc

class _$SatisfiableItem_AbsoluteTimelockImpl
    extends SatisfiableItem_AbsoluteTimelock {
  const _$SatisfiableItem_AbsoluteTimelockImpl({required this.value})
      : super._();

  @override
  final LockTime value;

  @override
  String toString() {
    return 'SatisfiableItem.absoluteTimelock(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_AbsoluteTimelockImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_AbsoluteTimelockImplCopyWith<
          _$SatisfiableItem_AbsoluteTimelockImpl>
      get copyWith => __$$SatisfiableItem_AbsoluteTimelockImplCopyWithImpl<
          _$SatisfiableItem_AbsoluteTimelockImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return absoluteTimelock(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return absoluteTimelock?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (absoluteTimelock != null) {
      return absoluteTimelock(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return absoluteTimelock(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return absoluteTimelock?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (absoluteTimelock != null) {
      return absoluteTimelock(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_AbsoluteTimelock extends SatisfiableItem {
  const factory SatisfiableItem_AbsoluteTimelock(
      {required final LockTime value}) = _$SatisfiableItem_AbsoluteTimelockImpl;
  const SatisfiableItem_AbsoluteTimelock._() : super._();

  LockTime get value;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_AbsoluteTimelockImplCopyWith<
          _$SatisfiableItem_AbsoluteTimelockImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_RelativeTimelockImplCopyWith<$Res> {
  factory _$$SatisfiableItem_RelativeTimelockImplCopyWith(
          _$SatisfiableItem_RelativeTimelockImpl value,
          $Res Function(_$SatisfiableItem_RelativeTimelockImpl) then) =
      __$$SatisfiableItem_RelativeTimelockImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$SatisfiableItem_RelativeTimelockImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res,
        _$SatisfiableItem_RelativeTimelockImpl>
    implements _$$SatisfiableItem_RelativeTimelockImplCopyWith<$Res> {
  __$$SatisfiableItem_RelativeTimelockImplCopyWithImpl(
      _$SatisfiableItem_RelativeTimelockImpl _value,
      $Res Function(_$SatisfiableItem_RelativeTimelockImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$SatisfiableItem_RelativeTimelockImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$SatisfiableItem_RelativeTimelockImpl
    extends SatisfiableItem_RelativeTimelock {
  const _$SatisfiableItem_RelativeTimelockImpl({required this.value})
      : super._();

  @override
  final int value;

  @override
  String toString() {
    return 'SatisfiableItem.relativeTimelock(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_RelativeTimelockImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_RelativeTimelockImplCopyWith<
          _$SatisfiableItem_RelativeTimelockImpl>
      get copyWith => __$$SatisfiableItem_RelativeTimelockImplCopyWithImpl<
          _$SatisfiableItem_RelativeTimelockImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return relativeTimelock(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return relativeTimelock?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (relativeTimelock != null) {
      return relativeTimelock(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return relativeTimelock(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return relativeTimelock?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (relativeTimelock != null) {
      return relativeTimelock(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_RelativeTimelock extends SatisfiableItem {
  const factory SatisfiableItem_RelativeTimelock({required final int value}) =
      _$SatisfiableItem_RelativeTimelockImpl;
  const SatisfiableItem_RelativeTimelock._() : super._();

  int get value;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_RelativeTimelockImplCopyWith<
          _$SatisfiableItem_RelativeTimelockImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_MultisigImplCopyWith<$Res> {
  factory _$$SatisfiableItem_MultisigImplCopyWith(
          _$SatisfiableItem_MultisigImpl value,
          $Res Function(_$SatisfiableItem_MultisigImpl) then) =
      __$$SatisfiableItem_MultisigImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<PkOrF> keys, BigInt threshold});
}

/// @nodoc
class __$$SatisfiableItem_MultisigImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res, _$SatisfiableItem_MultisigImpl>
    implements _$$SatisfiableItem_MultisigImplCopyWith<$Res> {
  __$$SatisfiableItem_MultisigImplCopyWithImpl(
      _$SatisfiableItem_MultisigImpl _value,
      $Res Function(_$SatisfiableItem_MultisigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keys = null,
    Object? threshold = null,
  }) {
    return _then(_$SatisfiableItem_MultisigImpl(
      keys: null == keys
          ? _value._keys
          : keys // ignore: cast_nullable_to_non_nullable
              as List<PkOrF>,
      threshold: null == threshold
          ? _value.threshold
          : threshold // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$SatisfiableItem_MultisigImpl extends SatisfiableItem_Multisig {
  const _$SatisfiableItem_MultisigImpl(
      {required final List<PkOrF> keys, required this.threshold})
      : _keys = keys,
        super._();

  final List<PkOrF> _keys;
  @override
  List<PkOrF> get keys {
    if (_keys is EqualUnmodifiableListView) return _keys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_keys);
  }

  @override
  final BigInt threshold;

  @override
  String toString() {
    return 'SatisfiableItem.multisig(keys: $keys, threshold: $threshold)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_MultisigImpl &&
            const DeepCollectionEquality().equals(other._keys, _keys) &&
            (identical(other.threshold, threshold) ||
                other.threshold == threshold));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_keys), threshold);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_MultisigImplCopyWith<_$SatisfiableItem_MultisigImpl>
      get copyWith => __$$SatisfiableItem_MultisigImplCopyWithImpl<
          _$SatisfiableItem_MultisigImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return multisig(keys, threshold);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return multisig?.call(keys, threshold);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (multisig != null) {
      return multisig(keys, threshold);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return multisig(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return multisig?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (multisig != null) {
      return multisig(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_Multisig extends SatisfiableItem {
  const factory SatisfiableItem_Multisig(
      {required final List<PkOrF> keys,
      required final BigInt threshold}) = _$SatisfiableItem_MultisigImpl;
  const SatisfiableItem_Multisig._() : super._();

  List<PkOrF> get keys;
  BigInt get threshold;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_MultisigImplCopyWith<_$SatisfiableItem_MultisigImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SatisfiableItem_ThreshImplCopyWith<$Res> {
  factory _$$SatisfiableItem_ThreshImplCopyWith(
          _$SatisfiableItem_ThreshImpl value,
          $Res Function(_$SatisfiableItem_ThreshImpl) then) =
      __$$SatisfiableItem_ThreshImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<BdkPolicy> items, BigInt threshold});
}

/// @nodoc
class __$$SatisfiableItem_ThreshImplCopyWithImpl<$Res>
    extends _$SatisfiableItemCopyWithImpl<$Res, _$SatisfiableItem_ThreshImpl>
    implements _$$SatisfiableItem_ThreshImplCopyWith<$Res> {
  __$$SatisfiableItem_ThreshImplCopyWithImpl(
      _$SatisfiableItem_ThreshImpl _value,
      $Res Function(_$SatisfiableItem_ThreshImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = null,
    Object? threshold = null,
  }) {
    return _then(_$SatisfiableItem_ThreshImpl(
      items: null == items
          ? _value._items
          : items // ignore: cast_nullable_to_non_nullable
              as List<BdkPolicy>,
      threshold: null == threshold
          ? _value.threshold
          : threshold // ignore: cast_nullable_to_non_nullable
              as BigInt,
    ));
  }
}

/// @nodoc

class _$SatisfiableItem_ThreshImpl extends SatisfiableItem_Thresh {
  const _$SatisfiableItem_ThreshImpl(
      {required final List<BdkPolicy> items, required this.threshold})
      : _items = items,
        super._();

  final List<BdkPolicy> _items;
  @override
  List<BdkPolicy> get items {
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_items);
  }

  @override
  final BigInt threshold;

  @override
  String toString() {
    return 'SatisfiableItem.thresh(items: $items, threshold: $threshold)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SatisfiableItem_ThreshImpl &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.threshold, threshold) ||
                other.threshold == threshold));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_items), threshold);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SatisfiableItem_ThreshImplCopyWith<_$SatisfiableItem_ThreshImpl>
      get copyWith => __$$SatisfiableItem_ThreshImplCopyWithImpl<
          _$SatisfiableItem_ThreshImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(PkOrF key) ecdsaSignature,
    required TResult Function(PkOrF key) schnorrSignature,
    required TResult Function(String hash) sha256Preimage,
    required TResult Function(String hash) hash256Preimage,
    required TResult Function(String hash) ripemd160Preimage,
    required TResult Function(String hash) hash160Preimage,
    required TResult Function(LockTime value) absoluteTimelock,
    required TResult Function(int value) relativeTimelock,
    required TResult Function(List<PkOrF> keys, BigInt threshold) multisig,
    required TResult Function(List<BdkPolicy> items, BigInt threshold) thresh,
  }) {
    return thresh(items, threshold);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(PkOrF key)? ecdsaSignature,
    TResult? Function(PkOrF key)? schnorrSignature,
    TResult? Function(String hash)? sha256Preimage,
    TResult? Function(String hash)? hash256Preimage,
    TResult? Function(String hash)? ripemd160Preimage,
    TResult? Function(String hash)? hash160Preimage,
    TResult? Function(LockTime value)? absoluteTimelock,
    TResult? Function(int value)? relativeTimelock,
    TResult? Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult? Function(List<BdkPolicy> items, BigInt threshold)? thresh,
  }) {
    return thresh?.call(items, threshold);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(PkOrF key)? ecdsaSignature,
    TResult Function(PkOrF key)? schnorrSignature,
    TResult Function(String hash)? sha256Preimage,
    TResult Function(String hash)? hash256Preimage,
    TResult Function(String hash)? ripemd160Preimage,
    TResult Function(String hash)? hash160Preimage,
    TResult Function(LockTime value)? absoluteTimelock,
    TResult Function(int value)? relativeTimelock,
    TResult Function(List<PkOrF> keys, BigInt threshold)? multisig,
    TResult Function(List<BdkPolicy> items, BigInt threshold)? thresh,
    required TResult orElse(),
  }) {
    if (thresh != null) {
      return thresh(items, threshold);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SatisfiableItem_EcdsaSignature value)
        ecdsaSignature,
    required TResult Function(SatisfiableItem_SchnorrSignature value)
        schnorrSignature,
    required TResult Function(SatisfiableItem_Sha256Preimage value)
        sha256Preimage,
    required TResult Function(SatisfiableItem_Hash256Preimage value)
        hash256Preimage,
    required TResult Function(SatisfiableItem_Ripemd160Preimage value)
        ripemd160Preimage,
    required TResult Function(SatisfiableItem_Hash160Preimage value)
        hash160Preimage,
    required TResult Function(SatisfiableItem_AbsoluteTimelock value)
        absoluteTimelock,
    required TResult Function(SatisfiableItem_RelativeTimelock value)
        relativeTimelock,
    required TResult Function(SatisfiableItem_Multisig value) multisig,
    required TResult Function(SatisfiableItem_Thresh value) thresh,
  }) {
    return thresh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult? Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult? Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult? Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult? Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult? Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult? Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult? Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult? Function(SatisfiableItem_Multisig value)? multisig,
    TResult? Function(SatisfiableItem_Thresh value)? thresh,
  }) {
    return thresh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SatisfiableItem_EcdsaSignature value)? ecdsaSignature,
    TResult Function(SatisfiableItem_SchnorrSignature value)? schnorrSignature,
    TResult Function(SatisfiableItem_Sha256Preimage value)? sha256Preimage,
    TResult Function(SatisfiableItem_Hash256Preimage value)? hash256Preimage,
    TResult Function(SatisfiableItem_Ripemd160Preimage value)?
        ripemd160Preimage,
    TResult Function(SatisfiableItem_Hash160Preimage value)? hash160Preimage,
    TResult Function(SatisfiableItem_AbsoluteTimelock value)? absoluteTimelock,
    TResult Function(SatisfiableItem_RelativeTimelock value)? relativeTimelock,
    TResult Function(SatisfiableItem_Multisig value)? multisig,
    TResult Function(SatisfiableItem_Thresh value)? thresh,
    required TResult orElse(),
  }) {
    if (thresh != null) {
      return thresh(this);
    }
    return orElse();
  }
}

abstract class SatisfiableItem_Thresh extends SatisfiableItem {
  const factory SatisfiableItem_Thresh(
      {required final List<BdkPolicy> items,
      required final BigInt threshold}) = _$SatisfiableItem_ThreshImpl;
  const SatisfiableItem_Thresh._() : super._();

  List<BdkPolicy> get items;
  BigInt get threshold;
  @JsonKey(ignore: true)
  _$$SatisfiableItem_ThreshImplCopyWith<_$SatisfiableItem_ThreshImpl>
      get copyWith => throw _privateConstructorUsedError;
}
