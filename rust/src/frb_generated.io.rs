// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.25.

// Section: imports

use super::*;
use crate::api::types::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::transform_result_dco;
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate_io!();

// Section: dart2rust

impl CstDecode<bdk::bitcoin::Address> for usize {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> bdk::bitcoin::Address {
        CstDecode::<
            RustOpaqueNom<
                flutter_rust_bridge::for_generated::rust_async::RwLock<bdk::bitcoin::Address>,
            >,
        >::cst_decode(self)
        .rust_auto_opaque_decode_owned()
    }
}
impl
    CstDecode<
        RustOpaqueNom<
            flutter_rust_bridge::for_generated::rust_async::RwLock<bdk::bitcoin::Address>,
        >,
    > for usize
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(
        self,
    ) -> RustOpaqueNom<flutter_rust_bridge::for_generated::rust_async::RwLock<bdk::bitcoin::Address>>
    {
        unsafe { decode_rust_opaque_nom(self as _) }
    }
}
impl CstDecode<String> for *mut wire_cst_list_prim_u_8_strict {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> String {
        let vec: Vec<u8> = self.cst_decode();
        String::from_utf8(vec).unwrap()
    }
}
impl CstDecode<crate::api::types::AddressBase> for wire_cst_address_base {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::AddressBase {
        crate::api::types::AddressBase(self.field0.cst_decode())
    }
}
impl CstDecode<crate::util::error::BdkError> for wire_cst_bdk_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::util::error::BdkError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.HexError };
                crate::util::error::BdkError::HexError(ans.field0.cst_decode())
            }
            1 => {
                let ans = unsafe { self.kind.ConsensusError };
                crate::util::error::BdkError::ConsensusError(ans.field0.cst_decode())
            }
            2 => {
                let ans = unsafe { self.kind.AddressError };
                crate::util::error::BdkError::AddressError(ans.field0.cst_decode())
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::util::error::BitcoinAddressError> for wire_cst_bitcoin_address_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::util::error::BitcoinAddressError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.Base58 };
                crate::util::error::BitcoinAddressError::Base58(ans.field0.cst_decode())
            }
            1 => {
                let ans = unsafe { self.kind.Bech32 };
                crate::util::error::BitcoinAddressError::Bech32(ans.field0.cst_decode())
            }
            2 => crate::util::error::BitcoinAddressError::EmptyBech32Payload,
            3 => {
                let ans = unsafe { self.kind.InvalidBech32Variant };
                crate::util::error::BitcoinAddressError::InvalidBech32Variant {
                    expected: ans.expected.cst_decode(),
                    found: ans.found.cst_decode(),
                }
            }
            4 => {
                let ans = unsafe { self.kind.InvalidWitnessVersion };
                crate::util::error::BitcoinAddressError::InvalidWitnessVersion(
                    ans.field0.cst_decode(),
                )
            }
            5 => {
                let ans = unsafe { self.kind.UnparsableWitnessVersion };
                crate::util::error::BitcoinAddressError::UnparsableWitnessVersion(
                    ans.field0.cst_decode(),
                )
            }
            6 => crate::util::error::BitcoinAddressError::MalformedWitnessVersion,
            7 => {
                let ans = unsafe { self.kind.InvalidWitnessProgramLength };
                crate::util::error::BitcoinAddressError::InvalidWitnessProgramLength(
                    ans.field0.cst_decode(),
                )
            }
            8 => {
                let ans = unsafe { self.kind.InvalidSegwitV0ProgramLength };
                crate::util::error::BitcoinAddressError::InvalidSegwitV0ProgramLength(
                    ans.field0.cst_decode(),
                )
            }
            9 => crate::util::error::BitcoinAddressError::UncompressedPubkey,
            10 => crate::util::error::BitcoinAddressError::ExcessiveScriptSize,
            11 => crate::util::error::BitcoinAddressError::UnrecognizedScript,
            12 => {
                let ans = unsafe { self.kind.UnknownAddressType };
                crate::util::error::BitcoinAddressError::UnknownAddressType(ans.field0.cst_decode())
            }
            13 => {
                let ans = unsafe { self.kind.NetworkValidation };
                crate::util::error::BitcoinAddressError::NetworkValidation {
                    network_required: ans.network_required.cst_decode(),
                    network_found: ans.network_found.cst_decode(),
                    address: ans.address.cst_decode(),
                }
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::util::error::BitcoinConsensusError> for wire_cst_bitcoin_consensus_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::util::error::BitcoinConsensusError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.Io };
                crate::util::error::BitcoinConsensusError::Io(ans.field0.cst_decode())
            }
            1 => {
                let ans = unsafe { self.kind.OversizedVectorAllocation };
                crate::util::error::BitcoinConsensusError::OversizedVectorAllocation {
                    requested: ans.requested.cst_decode(),
                    max: ans.max.cst_decode(),
                }
            }
            2 => {
                let ans = unsafe { self.kind.InvalidChecksum };
                crate::util::error::BitcoinConsensusError::InvalidChecksum {
                    expected: ans.expected.cst_decode(),
                    actual: ans.actual.cst_decode(),
                }
            }
            3 => crate::util::error::BitcoinConsensusError::NonMinimalVarInt,
            4 => {
                let ans = unsafe { self.kind.ParseFailed };
                crate::util::error::BitcoinConsensusError::ParseFailed(ans.field0.cst_decode())
            }
            5 => {
                let ans = unsafe { self.kind.UnsupportedSegwitFlag };
                crate::util::error::BitcoinConsensusError::UnsupportedSegwitFlag(
                    ans.field0.cst_decode(),
                )
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::util::error::BitcoinHexError> for wire_cst_bitcoin_hex_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::util::error::BitcoinHexError {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.InvalidChar };
                crate::util::error::BitcoinHexError::InvalidChar(ans.field0.cst_decode())
            }
            1 => {
                let ans = unsafe { self.kind.OddLengthString };
                crate::util::error::BitcoinHexError::OddLengthString(ans.field0.cst_decode())
            }
            2 => {
                let ans = unsafe { self.kind.InvalidLength };
                crate::util::error::BitcoinHexError::InvalidLength(
                    ans.field0.cst_decode(),
                    ans.field1.cst_decode(),
                )
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::types::AddressBase> for *mut wire_cst_address_base {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::AddressBase {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::types::AddressBase>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::util::error::BitcoinAddressError> for *mut wire_cst_bitcoin_address_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::util::error::BitcoinAddressError {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::util::error::BitcoinAddressError>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::util::error::BitcoinConsensusError>
    for *mut wire_cst_bitcoin_consensus_error
{
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::util::error::BitcoinConsensusError {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::util::error::BitcoinConsensusError>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::util::error::BitcoinHexError> for *mut wire_cst_bitcoin_hex_error {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::util::error::BitcoinHexError {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::util::error::BitcoinHexError>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::types::ScriptBufBase> for *mut wire_cst_script_buf_base {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::ScriptBufBase {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::types::ScriptBufBase>::cst_decode(*wrap).into()
    }
}
impl CstDecode<crate::api::types::TransactionBase> for *mut wire_cst_transaction_base {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::TransactionBase {
        let wrap = unsafe { flutter_rust_bridge::for_generated::box_from_leak_ptr(self) };
        CstDecode::<crate::api::types::TransactionBase>::cst_decode(*wrap).into()
    }
}
impl CstDecode<Vec<Vec<u8>>> for *mut wire_cst_list_list_prim_u_8_strict {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<Vec<u8>> {
        let vec = unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        };
        vec.into_iter().map(CstDecode::cst_decode).collect()
    }
}
impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_loose {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<u8> {
        unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        }
    }
}
impl CstDecode<Vec<u8>> for *mut wire_cst_list_prim_u_8_strict {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<u8> {
        unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        }
    }
}
impl CstDecode<Vec<crate::api::types::TxIn>> for *mut wire_cst_list_tx_in {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::types::TxIn> {
        let vec = unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        };
        vec.into_iter().map(CstDecode::cst_decode).collect()
    }
}
impl CstDecode<Vec<crate::api::types::TxOut>> for *mut wire_cst_list_tx_out {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> Vec<crate::api::types::TxOut> {
        let vec = unsafe {
            let wrap = flutter_rust_bridge::for_generated::box_from_leak_ptr(self);
            flutter_rust_bridge::for_generated::vec_from_leak_ptr(wrap.ptr, wrap.len)
        };
        vec.into_iter().map(CstDecode::cst_decode).collect()
    }
}
impl CstDecode<crate::api::types::OutPoint> for wire_cst_out_point {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::OutPoint {
        crate::api::types::OutPoint {
            txid: self.txid.cst_decode(),
            vout: self.vout.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::Payload> for wire_cst_payload {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::Payload {
        match self.tag {
            0 => {
                let ans = unsafe { self.kind.PubkeyHash };
                crate::api::types::Payload::PubkeyHash {
                    pubkey_hash: ans.pubkey_hash.cst_decode(),
                }
            }
            1 => {
                let ans = unsafe { self.kind.ScriptHash };
                crate::api::types::Payload::ScriptHash {
                    script_hash: ans.script_hash.cst_decode(),
                }
            }
            2 => {
                let ans = unsafe { self.kind.WitnessProgram };
                crate::api::types::Payload::WitnessProgram {
                    version: ans.version.cst_decode(),
                    program: ans.program.cst_decode(),
                }
            }
            _ => unreachable!(),
        }
    }
}
impl CstDecode<crate::api::types::ScriptBufBase> for wire_cst_script_buf_base {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::ScriptBufBase {
        crate::api::types::ScriptBufBase {
            bytes: self.bytes.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::TransactionBase> for wire_cst_transaction_base {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::TransactionBase {
        crate::api::types::TransactionBase {
            inner: self.inner.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::TxIn> for wire_cst_tx_in {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::TxIn {
        crate::api::types::TxIn {
            previous_output: self.previous_output.cst_decode(),
            script_sig: self.script_sig.cst_decode(),
            sequence: self.sequence.cst_decode(),
            witness: self.witness.cst_decode(),
        }
    }
}
impl CstDecode<crate::api::types::TxOut> for wire_cst_tx_out {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> crate::api::types::TxOut {
        crate::api::types::TxOut {
            value: self.value.cst_decode(),
            script_pubkey: self.script_pubkey.cst_decode(),
        }
    }
}
impl CstDecode<[u8; 4]> for *mut wire_cst_list_prim_u_8_strict {
    // Codec=Cst (C-struct based), see doc to use other codecs
    fn cst_decode(self) -> [u8; 4] {
        let vec: Vec<u8> = self.cst_decode();
        flutter_rust_bridge::for_generated::from_vec_to_array(vec)
    }
}
impl NewWithNullPtr for wire_cst_address_base {
    fn new_with_null_ptr() -> Self {
        Self {
            field0: Default::default(),
        }
    }
}
impl Default for wire_cst_address_base {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_bdk_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: BdkErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_bdk_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_bitcoin_address_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: BitcoinAddressErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_bitcoin_address_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_bitcoin_consensus_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: BitcoinConsensusErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_bitcoin_consensus_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_bitcoin_hex_error {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: BitcoinHexErrorKind { nil__: () },
        }
    }
}
impl Default for wire_cst_bitcoin_hex_error {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_out_point {
    fn new_with_null_ptr() -> Self {
        Self {
            txid: core::ptr::null_mut(),
            vout: Default::default(),
        }
    }
}
impl Default for wire_cst_out_point {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_payload {
    fn new_with_null_ptr() -> Self {
        Self {
            tag: -1,
            kind: PayloadKind { nil__: () },
        }
    }
}
impl Default for wire_cst_payload {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_script_buf_base {
    fn new_with_null_ptr() -> Self {
        Self {
            bytes: core::ptr::null_mut(),
        }
    }
}
impl Default for wire_cst_script_buf_base {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_transaction_base {
    fn new_with_null_ptr() -> Self {
        Self {
            inner: core::ptr::null_mut(),
        }
    }
}
impl Default for wire_cst_transaction_base {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_tx_in {
    fn new_with_null_ptr() -> Self {
        Self {
            previous_output: Default::default(),
            script_sig: Default::default(),
            sequence: Default::default(),
            witness: core::ptr::null_mut(),
        }
    }
}
impl Default for wire_cst_tx_in {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}
impl NewWithNullPtr for wire_cst_tx_out {
    fn new_with_null_ptr() -> Self {
        Self {
            value: Default::default(),
            script_pubkey: Default::default(),
        }
    }
}
impl Default for wire_cst_tx_out {
    fn default() -> Self {
        Self::new_with_null_ptr()
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_AddressBase_as_string(
    port_: i64,
    that: *mut wire_cst_address_base,
) {
    wire_AddressBase_as_string_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_AddressBase_from_script(
    port_: i64,
    script: *mut wire_cst_script_buf_base,
    network: i32,
) {
    wire_AddressBase_from_script_impl(port_, script, network)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_AddressBase_from_string(
    port_: i64,
    address: *mut wire_cst_list_prim_u_8_strict,
    network: i32,
) {
    wire_AddressBase_from_string_impl(port_, address, network)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_AddressBase_is_valid_for_network(
    port_: i64,
    that: *mut wire_cst_address_base,
    network: i32,
) {
    wire_AddressBase_is_valid_for_network_impl(port_, that, network)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_AddressBase_network(
    port_: i64,
    that: *mut wire_cst_address_base,
) {
    wire_AddressBase_network_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_AddressBase_payload(
    port_: i64,
    that: *mut wire_cst_address_base,
) {
    wire_AddressBase_payload_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_AddressBase_script_pubkey(
    port_: i64,
    that: *mut wire_cst_address_base,
) {
    wire_AddressBase_script_pubkey_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_AddressBase_to_qr_uri(
    port_: i64,
    that: *mut wire_cst_address_base,
) {
    wire_AddressBase_to_qr_uri_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_ScriptBufBase_empty(port_: i64) {
    wire_ScriptBufBase_empty_impl(port_)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_ScriptBufBase_from_hex(
    port_: i64,
    s: *mut wire_cst_list_prim_u_8_strict,
) {
    wire_ScriptBufBase_from_hex_impl(port_, s)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_ScriptBufBase_with_capacity(port_: i64, capacity: usize) {
    wire_ScriptBufBase_with_capacity_impl(port_, capacity)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_input(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_input_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_is_coin_base(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_is_coin_base_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_is_explicitly_rbf(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_is_explicitly_rbf_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_is_lock_time_enabled(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_is_lock_time_enabled_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_lock_time(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_lock_time_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_new(
    port_: i64,
    transaction_bytes: *mut wire_cst_list_prim_u_8_loose,
) {
    wire_TransactionBase_new_impl(port_, transaction_bytes)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_output(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_output_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_serialize(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_serialize_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_size(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_size_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_txid(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_txid_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_version(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_version_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_vsize(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_vsize_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_wire_TransactionBase_weight(
    port_: i64,
    that: *mut wire_cst_transaction_base,
) {
    wire_TransactionBase_weight_impl(port_, that)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockbdkbitcoinAddress(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<flutter_rust_bridge::for_generated::rust_async::RwLock<bdk :: bitcoin :: Address>>::increment_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedrust_asyncRwLockbdkbitcoinAddress(
    ptr: *const std::ffi::c_void,
) {
    unsafe {
        StdArc::<flutter_rust_bridge::for_generated::rust_async::RwLock<bdk :: bitcoin :: Address>>::decrement_strong_count(ptr as _);
    }
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_address_base() -> *mut wire_cst_address_base
{
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wire_cst_address_base::new_with_null_ptr())
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bitcoin_address_error(
) -> *mut wire_cst_bitcoin_address_error {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_bitcoin_address_error::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bitcoin_consensus_error(
) -> *mut wire_cst_bitcoin_consensus_error {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_bitcoin_consensus_error::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_bitcoin_hex_error(
) -> *mut wire_cst_bitcoin_hex_error {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_bitcoin_hex_error::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_script_buf_base(
) -> *mut wire_cst_script_buf_base {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_script_buf_base::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_box_autoadd_transaction_base(
) -> *mut wire_cst_transaction_base {
    flutter_rust_bridge::for_generated::new_leak_box_ptr(
        wire_cst_transaction_base::new_with_null_ptr(),
    )
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_list_prim_u_8_strict(
    len: i32,
) -> *mut wire_cst_list_list_prim_u_8_strict {
    let wrap = wire_cst_list_list_prim_u_8_strict {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
            <*mut wire_cst_list_prim_u_8_strict>::new_with_null_ptr(),
            len,
        ),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_8_loose(
    len: i32,
) -> *mut wire_cst_list_prim_u_8_loose {
    let ans = wire_cst_list_prim_u_8_loose {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_prim_u_8_strict(
    len: i32,
) -> *mut wire_cst_list_prim_u_8_strict {
    let ans = wire_cst_list_prim_u_8_strict {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(Default::default(), len),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(ans)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_tx_in(len: i32) -> *mut wire_cst_list_tx_in {
    let wrap = wire_cst_list_tx_in {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
            <wire_cst_tx_in>::new_with_null_ptr(),
            len,
        ),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
}

#[no_mangle]
pub extern "C" fn frbgen_bdk_flutter_cst_new_list_tx_out(len: i32) -> *mut wire_cst_list_tx_out {
    let wrap = wire_cst_list_tx_out {
        ptr: flutter_rust_bridge::for_generated::new_leak_vec_ptr(
            <wire_cst_tx_out>::new_with_null_ptr(),
            len,
        ),
        len,
    };
    flutter_rust_bridge::for_generated::new_leak_box_ptr(wrap)
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_address_base {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_bdk_error {
    tag: i32,
    kind: BdkErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union BdkErrorKind {
    HexError: wire_cst_BdkError_HexError,
    ConsensusError: wire_cst_BdkError_ConsensusError,
    AddressError: wire_cst_BdkError_AddressError,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BdkError_HexError {
    field0: *mut wire_cst_bitcoin_hex_error,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BdkError_ConsensusError {
    field0: *mut wire_cst_bitcoin_consensus_error,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BdkError_AddressError {
    field0: *mut wire_cst_bitcoin_address_error,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_bitcoin_address_error {
    tag: i32,
    kind: BitcoinAddressErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union BitcoinAddressErrorKind {
    Base58: wire_cst_BitcoinAddressError_Base58,
    Bech32: wire_cst_BitcoinAddressError_Bech32,
    InvalidBech32Variant: wire_cst_BitcoinAddressError_InvalidBech32Variant,
    InvalidWitnessVersion: wire_cst_BitcoinAddressError_InvalidWitnessVersion,
    UnparsableWitnessVersion: wire_cst_BitcoinAddressError_UnparsableWitnessVersion,
    InvalidWitnessProgramLength: wire_cst_BitcoinAddressError_InvalidWitnessProgramLength,
    InvalidSegwitV0ProgramLength: wire_cst_BitcoinAddressError_InvalidSegwitV0ProgramLength,
    UnknownAddressType: wire_cst_BitcoinAddressError_UnknownAddressType,
    NetworkValidation: wire_cst_BitcoinAddressError_NetworkValidation,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_Base58 {
    field0: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_Bech32 {
    field0: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_InvalidBech32Variant {
    expected: i32,
    found: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_InvalidWitnessVersion {
    field0: u8,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_UnparsableWitnessVersion {
    field0: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_InvalidWitnessProgramLength {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_InvalidSegwitV0ProgramLength {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_UnknownAddressType {
    field0: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinAddressError_NetworkValidation {
    network_required: i32,
    network_found: i32,
    address: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_bitcoin_consensus_error {
    tag: i32,
    kind: BitcoinConsensusErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union BitcoinConsensusErrorKind {
    Io: wire_cst_BitcoinConsensusError_Io,
    OversizedVectorAllocation: wire_cst_BitcoinConsensusError_OversizedVectorAllocation,
    InvalidChecksum: wire_cst_BitcoinConsensusError_InvalidChecksum,
    ParseFailed: wire_cst_BitcoinConsensusError_ParseFailed,
    UnsupportedSegwitFlag: wire_cst_BitcoinConsensusError_UnsupportedSegwitFlag,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinConsensusError_Io {
    field0: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinConsensusError_OversizedVectorAllocation {
    requested: usize,
    max: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinConsensusError_InvalidChecksum {
    expected: *mut wire_cst_list_prim_u_8_strict,
    actual: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinConsensusError_ParseFailed {
    field0: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinConsensusError_UnsupportedSegwitFlag {
    field0: u8,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_bitcoin_hex_error {
    tag: i32,
    kind: BitcoinHexErrorKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union BitcoinHexErrorKind {
    InvalidChar: wire_cst_BitcoinHexError_InvalidChar,
    OddLengthString: wire_cst_BitcoinHexError_OddLengthString,
    InvalidLength: wire_cst_BitcoinHexError_InvalidLength,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinHexError_InvalidChar {
    field0: u8,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinHexError_OddLengthString {
    field0: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_BitcoinHexError_InvalidLength {
    field0: usize,
    field1: usize,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_list_prim_u_8_strict {
    ptr: *mut *mut wire_cst_list_prim_u_8_strict,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_prim_u_8_loose {
    ptr: *mut u8,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_prim_u_8_strict {
    ptr: *mut u8,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_tx_in {
    ptr: *mut wire_cst_tx_in,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_list_tx_out {
    ptr: *mut wire_cst_tx_out,
    len: i32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_out_point {
    txid: *mut wire_cst_list_prim_u_8_strict,
    vout: u32,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_payload {
    tag: i32,
    kind: PayloadKind,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub union PayloadKind {
    PubkeyHash: wire_cst_Payload_PubkeyHash,
    ScriptHash: wire_cst_Payload_ScriptHash,
    WitnessProgram: wire_cst_Payload_WitnessProgram,
    nil__: (),
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Payload_PubkeyHash {
    pubkey_hash: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Payload_ScriptHash {
    script_hash: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_Payload_WitnessProgram {
    version: i32,
    program: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_script_buf_base {
    bytes: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_transaction_base {
    inner: *mut wire_cst_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_tx_in {
    previous_output: wire_cst_out_point,
    script_sig: wire_cst_script_buf_base,
    sequence: u32,
    witness: *mut wire_cst_list_list_prim_u_8_strict,
}
#[repr(C)]
#[derive(Clone, Copy)]
pub struct wire_cst_tx_out {
    value: u64,
    script_pubkey: wire_cst_script_buf_base,
}
