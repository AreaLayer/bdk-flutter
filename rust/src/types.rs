use serde::{Deserialize, Serialize};

// #[derive(Clone)]
// pub(crate) struct  BdkInfo{
//     pub wallets: HashMap<String, Arc<Wallet>>,
//     pub blockchain: HashMap<String, Arc<AnyBlockchain>>,
// }

pub struct TxOut {
    /// The value of the output, in satoshis.
    pub(crate) value: u64,
    /// The address of the output.
    pub(crate) address: String,
}


/// A reference to a transaction output.
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct OutPoint {
    /// The referenced transaction's txid.
    pub(crate) txid: String,
    /// The index of the referenced output in its transaction's vout.
    pub(crate) vout: u32,
}

pub struct LocalUtxo {
    pub outpoint: OutPoint,
    pub txout: TxOut,
    // keychain: KeychainKind,
    pub is_spent: bool,
}

#[derive(Deserialize)]
pub struct Balance {
    // All coinbase outputs not yet matured
    pub immature: u64,
    /// Unconfirmed UTXOs generated by a wallet tx
    pub trusted_pending: u64,
    /// Unconfirmed UTXOs received from an external wallet
    pub untrusted_pending: u64,
    /// Confirmed and immediately spendable balance
    pub confirmed: u64,
    /// Get sum of trusted_pending and confirmed coins
    pub spendable: u64,
    /// Get the whole balance visible to the wallet
    pub total: u64,
}

pub enum AddressIndex {
    New,
    LastUnused,
}

#[repr(C)]
pub struct AddressInfo {
    pub index: u32,
    pub address: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Default, Serialize)]
pub struct TransactionDetails {
    /// Transaction id.
    pub txid: String,
    /// Received value (sats)
    /// Sum of owned outputs of this transaction.
    pub received: u64,
    /// Sent value (sats)
    /// Sum of owned inputs of this transaction.
    pub sent: u64,
    /// Fee value (sats) if confirmed.
    /// The availability of the fee depends on the backend. It's never None with an Electrum
    /// Server backend, but it could be None with a Bitcoin RPC node without txindex that receive
    /// funds while offline.
    pub fee: Option<u64>,
    /// If the transaction is confirmed, contains height and timestamp of the block containing the
    /// transaction, unconfirmed transaction contains `None`.
    pub confirmation_time: Option<BlockTime>,
}

#[derive(Debug, Clone, PartialEq, Eq, Deserialize, Serialize)]
pub struct BlockTime {
    pub height: u32,
    pub timestamp: u64,
}

#[derive(Clone, Serialize, Deserialize, )]
pub struct ScriptAmount {
    pub script: String,
    pub amount: u64,
}

#[allow(dead_code)]
#[derive(Clone, Debug)]
pub enum RbfValue {
    RbfDefault,
    Value(u32),
}

/// The result after calling the TxBuilder finish() function. Contains unsigned PSBT and
/// transaction details.
pub struct TxBuilderResult {
    pub psbt: String,
    pub transaction_details: TransactionDetails,
}

pub struct ElectrumConfig {
    pub url: String,
    pub socks5: Option<String>,
    pub retry: u8,
    pub timeout: Option<u8>,
    pub stop_gap: u64,
}

pub struct EsploraConfig {
    pub base_url: String,
    pub proxy: Option<String>,
    pub concurrency: Option<u8>,
    pub stop_gap: u64,
    pub timeout: Option<u64>,
}

pub enum BlockchainConfig {
    ELECTRUM { config: ElectrumConfig },
    ESPLORA { config: EsploraConfig },
}

pub struct SqliteDbConfiguration {
    pub path: String,
}

pub struct SledDbConfiguration {
    pub path: String,
    pub tree_name: String,
}

pub enum DatabaseConfig {
    MEMORY,
    SQLITE { config: SqliteDbConfiguration },
    SLED { config: SledDbConfiguration },
}

#[allow(dead_code)]
pub enum KeyChainKind {
    EXTERNAL,
    INTERNAL,
}

#[derive(Clone)]
pub enum Network {
    TESTNET,
    REGTEST,
    BITCOIN,
    SIGNET,
}

pub enum WordCount {
    WORDS12,
    WORDS18,
    WORDS24,
}